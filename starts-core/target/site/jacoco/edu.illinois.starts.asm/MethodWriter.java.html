<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodWriter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">starts-core</a> &gt; <a href="index.source.html" class="el_package">edu.illinois.starts.asm</a> &gt; <span class="el_source">MethodWriter.java</span></div><h1>MethodWriter.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.illinois.starts.asm;


/**
 * A {@link MethodVisitor} that generates methods in bytecode form. Each visit
 * method of this class appends the bytecode corresponding to the visited
 * instruction to a byte vector, in the order these methods are called.
 *
 * @author Eric Bruneton
 * @author Eugene Kuleshov
 */
class MethodWriter extends MethodVisitor {

    /**
     * Pseudo access flag used to denote constructors.
     */
    static final int ACC_CONSTRUCTOR = 0x80000;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero.
     */
    static final int SAME_FRAME = 0; // to 63 (0-3f)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64; // to 127 (40-7f)

    /**
     * Reserved for future use
     */
    static final int RESERVED = 128;

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is 1. Offset is bigger then 63;
     */
    static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247; // f7

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that the k last locals are absent. The value of k is given
     * by the formula 251-frame_type.
     */
    static final int CHOP_FRAME = 248; // to 250 (f8-fA)

    /**
     * Frame has exactly the same locals as the previous stack map frame and
     * number of stack items is zero. Offset is bigger then 63;
     */
    static final int SAME_FRAME_EXTENDED = 251; // fb

    /**
     * Frame where current locals are the same as the locals in the previous
     * frame, except that k additional locals are defined. The value of k is
     * given by the formula frame_type-251.
     */
    static final int APPEND_FRAME = 252; // to 254 // fc-fe

    /**
     * Full frame
     */
    static final int FULL_FRAME = 255; // ff

    /**
     * Indicates that the stack map frames must be recomputed from scratch. In
     * this case the maximum stack size and number of local variables is also
     * recomputed from scratch.
     *
     * @see #compute
     */
    private static final int FRAMES = 0;

    /**
     * Indicates that the maximum stack size and number of local variables must
     * be automatically computed.
     *
     * @see #compute
     */
    private static final int MAXS = 1;

    /**
     * Indicates that nothing must be automatically computed.
     *
     * @see #compute
     */
    private static final int NOTHING = 2;

    /**
     * The class writer to which this method must be added.
     */
    final ClassWriter cw;

    /**
     * Access flags of this method.
     */
    private int access;

    /**
     * The index of the constant pool item that contains the name of this
     * method.
     */
    private final int name;

    /**
     * The index of the constant pool item that contains the descriptor of this
     * method.
     */
    private final int desc;

    /**
     * The descriptor of this method.
     */
    private final String descriptor;

    /**
     * The signature of this method.
     */
    String signature;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the index of the first byte to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderOffset;

    /**
     * If not zero, indicates that the code of this method must be copied from
     * the ClassReader associated to this writer in &lt;code&gt;cw.cr&lt;/code&gt;. More
     * precisely, this field gives the number of bytes to copied from
     * &lt;code&gt;cw.cr.b&lt;/code&gt;.
     */
    int classReaderLength;

    /**
     * Number of exceptions that can be thrown by this method.
     */
    int exceptionCount;

    /**
     * The exceptions that can be thrown by this method. More precisely, this
     * array contains the indexes of the constant pool items that contain the
     * internal names of these exception classes.
     */
    int[] exceptions;

    /**
     * The annotation default attribute of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private ByteVector annd;

    /**
     * The runtime visible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter anns;

    /**
     * The runtime invisible annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ianns;

    /**
     * The runtime visible type annotations of this method. May be &lt;tt&gt;null&lt;/tt&gt;
     * .
     */
    private AnnotationWriter tanns;

    /**
     * The runtime invisible type annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter itanns;

    /**
     * The runtime visible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] panns;

    /**
     * The runtime invisible parameter annotations of this method. May be
     * &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter[] ipanns;

    /**
     * The number of synthetic parameters of this method.
     */
    private int synthetics;

    /**
     * The non standard attributes of the method.
     */
    private Attribute attrs;

    /**
     * The bytecode of this method.
     */
<span class="nc" id="L232">    private ByteVector code = new ByteVector();</span>

    /**
     * Maximum stack size of this method.
     */
    private int maxStack;

    /**
     * Maximum number of local variables for this method.
     */
    private int maxLocals;

    /**
     * Number of local variables in the current stack map frame.
     */
    private int currentLocals;

    /**
     * Number of stack map frames in the StackMapTable attribute.
     */
    private int frameCount;

    /**
     * The StackMapTable attribute.
     */
    private ByteVector stackMap;

    /**
     * The offset of the last frame that was written in the StackMapTable
     * attribute.
     */
    private int previousFrameOffset;

    /**
     * The last frame that was written in the StackMapTable attribute.
     *
     * @see #frame
     */
    private int[] previousFrame;

    /**
     * The current stack map frame. The first element contains the offset of the
     * instruction to which the frame corresponds, the second element is the
     * number of locals and the third one is the number of stack elements. The
     * local variables start at index 3 and are followed by the operand stack
     * values. In summary frame[0] = offset, frame[1] = nLocal, frame[2] =
     * nStack, frame[3] = nLocal. All types are encoded as integers, with the
     * same format as the one used in {@link Label}, but limited to BASE types.
     */
    private int[] frame;

    /**
     * Number of elements in the exception handler list.
     */
    private int handlerCount;

    /**
     * The first element in the exception handler list.
     */
    private Handler firstHandler;

    /**
     * The last element in the exception handler list.
     */
    private Handler lastHandler;

    /**
     * Number of entries in the MethodParameters attribute.
     */
    private int methodParametersCount;

    /**
     * The MethodParameters attribute.
     */
    private ByteVector methodParameters;

    /**
     * Number of entries in the LocalVariableTable attribute.
     */
    private int localVarCount;

    /**
     * The LocalVariableTable attribute.
     */
    private ByteVector localVar;

    /**
     * Number of entries in the LocalVariableTypeTable attribute.
     */
    private int localVarTypeCount;

    /**
     * The LocalVariableTypeTable attribute.
     */
    private ByteVector localVarType;

    /**
     * Number of entries in the LineNumberTable attribute.
     */
    private int lineNumberCount;

    /**
     * The LineNumberTable attribute.
     */
    private ByteVector lineNumber;

    /**
     * The start offset of the last visited instruction.
     */
    private int lastCodeOffset;

    /**
     * The runtime visible type annotations of the code. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ctanns;

    /**
     * The runtime invisible type annotations of the code. May be &lt;tt&gt;null&lt;/tt&gt;.
     */
    private AnnotationWriter ictanns;

    /**
     * The non standard attributes of the method's code.
     */
    private Attribute cattrs;

    /**
     * Indicates if some jump instructions are too small and need to be resized.
     */
    private boolean resize;

    /**
     * The number of subroutines in this method.
     */
    private int subroutines;

    // ------------------------------------------------------------------------

    /*
     * Fields for the control flow graph analysis algorithm (used to compute the
     * maximum stack size). A control flow graph contains one node per &quot;basic
     * block&quot;, and one edge per &quot;jump&quot; from one basic block to another. Each
     * node (i.e., each basic block) is represented by the Label object that
     * corresponds to the first instruction of this basic block. Each node also
     * stores the list of its successors in the graph, as a linked list of Edge
     * objects.
     */

    /**
     * Indicates what must be automatically computed.
     *
     * @see #FRAMES
     * @see #MAXS
     * @see #NOTHING
     */
    private final int compute;

    /**
     * A list of labels. This list is the list of basic blocks in the method,
     * i.e. a list of Label objects linked to each other by their
     * {@link Label#successor} field, in the order they are visited by
     * {@link MethodVisitor#visitLabel}, and starting with the first basic
     * block.
     */
    private Label labels;

    /**
     * The previous basic block.
     */
    private Label previousBlock;

    /**
     * The current basic block.
     */
    private Label currentBlock;

    /**
     * The (relative) stack size after the last visited instruction. This size
     * is relative to the beginning of the current basic block, i.e., the true
     * stack size after the last visited instruction is equal to the
     * {@link Label#inputStackTop beginStackSize} of the current basic block
     * plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int stackSize;

    /**
     * The (relative) maximum stack size after the last visited instruction.
     * This size is relative to the beginning of the current basic block, i.e.,
     * the true maximum stack size after the last visited instruction is equal
     * to the {@link Label#inputStackTop beginStackSize} of the current basic
     * block plus &lt;tt&gt;stackSize&lt;/tt&gt;.
     */
    private int maxStackSize;

    // ------------------------------------------------------------------------
    // Constructor
    // ------------------------------------------------------------------------

    /**
     * Constructs a new {@link MethodWriter}.
     *
     * @param cw
     *            the class writer in which the method must be added.
     * @param access
     *            the method's access flags (see {@link Opcodes}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type}).
     * @param signature
     *            the method's signature. May be &lt;tt&gt;null&lt;/tt&gt;.
     * @param exceptions
     *            the internal names of the method's exceptions. May be
     *            &lt;tt&gt;null&lt;/tt&gt;.
     * @param computeMaxs
     *            &lt;tt&gt;true&lt;/tt&gt; if the maximum stack size and number of local
     *            variables must be automatically computed.
     * @param computeFrames
     *            &lt;tt&gt;true&lt;/tt&gt; if the stack map tables must be recomputed from
     *            scratch.
     */
    MethodWriter(final ClassWriter cw, final int access, final String name,
                 final String desc, final String signature,
                 final String[] exceptions, final boolean computeMaxs,
                 final boolean computeFrames) {
<span class="nc" id="L457">        super(Opcodes.ASM5);</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">        if (cw.firstMethod == null) {</span>
<span class="nc" id="L459">            cw.firstMethod = this;</span>
        } else {
<span class="nc" id="L461">            cw.lastMethod.mv = this;</span>
        }
<span class="nc" id="L463">        cw.lastMethod = this;</span>
<span class="nc" id="L464">        this.cw = cw;</span>
<span class="nc" id="L465">        this.access = access;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (&quot;&lt;init&gt;&quot;.equals(name)) {</span>
<span class="nc" id="L467">            this.access |= ACC_CONSTRUCTOR;</span>
        }
<span class="nc" id="L469">        this.name = cw.newUTF8(name);</span>
<span class="nc" id="L470">        this.desc = cw.newUTF8(desc);</span>
<span class="nc" id="L471">        this.descriptor = desc;</span>
        if (ClassReader.SIGNATURES) {
<span class="nc" id="L473">            this.signature = signature;</span>
        }
<span class="nc bnc" id="L475" title="All 4 branches missed.">        if (exceptions != null &amp;&amp; exceptions.length &gt; 0) {</span>
<span class="nc" id="L476">            exceptionCount = exceptions.length;</span>
<span class="nc" id="L477">            this.exceptions = new int[exceptionCount];</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="nc" id="L479">                this.exceptions[i] = cw.newClass(exceptions[i]);</span>
            }
        }
<span class="nc bnc" id="L482" title="All 4 branches missed.">        this.compute = computeFrames ? FRAMES : (computeMaxs ? MAXS : NOTHING);</span>
<span class="nc bnc" id="L483" title="All 4 branches missed.">        if (computeMaxs || computeFrames) {</span>
            // updates maxLocals
<span class="nc" id="L485">            int size = Type.getArgumentsAndReturnSizes(descriptor) &gt;&gt; 2;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">            if ((access &amp; Opcodes.ACC_STATIC) != 0) {</span>
<span class="nc" id="L487">                --size;</span>
            }
<span class="nc" id="L489">            maxLocals = size;</span>
<span class="nc" id="L490">            currentLocals = size;</span>
            // creates and visits the label for the first basic block
<span class="nc" id="L492">            labels = new Label();</span>
<span class="nc" id="L493">            labels.status |= Label.PUSHED;</span>
<span class="nc" id="L494">            visitLabel(labels);</span>
        }
<span class="nc" id="L496">    }</span>

    // ------------------------------------------------------------------------
    // Implementation of the MethodVisitor abstract class
    // ------------------------------------------------------------------------

    @Override
    public void visitParameter(String name, int access) {
<span class="nc bnc" id="L504" title="All 2 branches missed.">        if (methodParameters == null) {</span>
<span class="nc" id="L505">            methodParameters = new ByteVector();</span>
        }
<span class="nc" id="L507">        ++methodParametersCount;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">        methodParameters.putShort((name == null) ? 0 : cw.newUTF8(name))</span>
<span class="nc" id="L509">                .putShort(access);</span>
<span class="nc" id="L510">    }</span>

    @Override
    public AnnotationVisitor visitAnnotationDefault() {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L517">        annd = new ByteVector();</span>
<span class="nc" id="L518">        return new AnnotationWriter(cw, false, annd, null, 0);</span>
    }

    @Override
    public AnnotationVisitor visitAnnotation(final String desc,
                                                             final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L527">        ByteVector bv = new ByteVector();</span>
        // write type, and reserve space for values count
<span class="nc" id="L529">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L530">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L532">            aw.next = anns;</span>
<span class="nc" id="L533">            anns = aw;</span>
        } else {
<span class="nc" id="L535">            aw.next = ianns;</span>
<span class="nc" id="L536">            ianns = aw;</span>
        }
<span class="nc" id="L538">        return aw;</span>
    }

    @Override
    public AnnotationVisitor visitTypeAnnotation(final int typeRef,
                                                                 final TypePath typePath, final String desc, final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L547">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L549">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L551">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L552">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L554" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L555">            aw.next = tanns;</span>
<span class="nc" id="L556">            tanns = aw;</span>
        } else {
<span class="nc" id="L558">            aw.next = itanns;</span>
<span class="nc" id="L559">            itanns = aw;</span>
        }
<span class="nc" id="L561">        return aw;</span>
    }

    @Override
    public AnnotationVisitor visitParameterAnnotation(final int parameter,
                                                                      final String desc, final boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L570">        ByteVector bv = new ByteVector();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">        if (&quot;Ljava/lang/Synthetic;&quot;.equals(desc)) {</span>
            // workaround for a bug in javac with synthetic parameters
            // see ClassReader.readParameterAnnotations
<span class="nc" id="L574">            synthetics = Math.max(synthetics, parameter + 1);</span>
<span class="nc" id="L575">            return new AnnotationWriter(cw, false, bv, null, 0);</span>
        }
        // write type, and reserve space for values count
<span class="nc" id="L578">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L579">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv, 2);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            if (panns == null) {</span>
<span class="nc" id="L582">                panns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L584">            aw.next = panns[parameter];</span>
<span class="nc" id="L585">            panns[parameter] = aw;</span>
        } else {
<span class="nc bnc" id="L587" title="All 2 branches missed.">            if (ipanns == null) {</span>
<span class="nc" id="L588">                ipanns = new AnnotationWriter[Type.getArgumentTypes(descriptor).length];</span>
            }
<span class="nc" id="L590">            aw.next = ipanns[parameter];</span>
<span class="nc" id="L591">            ipanns[parameter] = aw;</span>
        }
<span class="nc" id="L593">        return aw;</span>
    }

    @Override
    public void visitAttribute(final Attribute attr) {
<span class="nc bnc" id="L598" title="All 2 branches missed.">        if (attr.isCodeAttribute()) {</span>
<span class="nc" id="L599">            attr.next = cattrs;</span>
<span class="nc" id="L600">            cattrs = attr;</span>
        } else {
<span class="nc" id="L602">            attr.next = attrs;</span>
<span class="nc" id="L603">            attrs = attr;</span>
        }
<span class="nc" id="L605">    }</span>

    @Override
    public void visitCode() {
<span class="nc" id="L609">    }</span>

    @Override
    public void visitFrame(final int type, final int nLocal,
            final Object[] local, final int nStack, final Object[] stack) {
<span class="nc bnc" id="L614" title="All 2 branches missed.">        if (!ClassReader.FRAMES || compute == FRAMES) {</span>
<span class="nc" id="L615">            return;</span>
        }

<span class="nc bnc" id="L618" title="All 2 branches missed.">        if (type == Opcodes.F_NEW) {</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">            if (previousFrame == null) {</span>
<span class="nc" id="L620">                visitImplicitFirstFrame();</span>
            }
<span class="nc" id="L622">            currentLocals = nLocal;</span>
<span class="nc" id="L623">            int frameIndex = startFrame(code.length, nLocal, nStack);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">            for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">                if (local[i] instanceof String) {</span>
<span class="nc" id="L626">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L627">                            | cw.addType((String) local[i]);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">                } else if (local[i] instanceof Integer) {</span>
<span class="nc" id="L629">                    frame[frameIndex++] = ((Integer) local[i]).intValue();</span>
                } else {
<span class="nc" id="L631">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L632">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) local[i]).position);
                }
            }
<span class="nc bnc" id="L636" title="All 2 branches missed.">            for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">                if (stack[i] instanceof String) {</span>
<span class="nc" id="L638">                    frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L639">                            | cw.addType((String) stack[i]);</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">                } else if (stack[i] instanceof Integer) {</span>
<span class="nc" id="L641">                    frame[frameIndex++] = ((Integer) stack[i]).intValue();</span>
                } else {
<span class="nc" id="L643">                    frame[frameIndex++] = Frame.UNINITIALIZED</span>
<span class="nc" id="L644">                            | cw.addUninitializedType(&quot;&quot;,</span>
                                    ((Label) stack[i]).position);
                }
            }
<span class="nc" id="L648">            endFrame();</span>
<span class="nc" id="L649">        } else {</span>
            int delta;
<span class="nc bnc" id="L651" title="All 2 branches missed.">            if (stackMap == null) {</span>
<span class="nc" id="L652">                stackMap = new ByteVector();</span>
<span class="nc" id="L653">                delta = code.length;</span>
            } else {
<span class="nc" id="L655">                delta = code.length - previousFrameOffset - 1;</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">                if (delta &lt; 0) {</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">                    if (type == Opcodes.F_SAME) {</span>
<span class="nc" id="L658">                        return;</span>
                    } else {
<span class="nc" id="L660">                        throw new IllegalStateException();</span>
                    }
                }
            }

<span class="nc bnc" id="L665" title="All 6 branches missed.">            switch (type) {</span>
            case Opcodes.F_FULL:
<span class="nc" id="L667">                currentLocals = nLocal;</span>
<span class="nc" id="L668">                stackMap.putByte(FULL_FRAME).putShort(delta).putShort(nLocal);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">                for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L670">                    writeFrameType(local[i]);</span>
                }
<span class="nc" id="L672">                stackMap.putShort(nStack);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">                for (int i = 0; i &lt; nStack; ++i) {</span>
<span class="nc" id="L674">                    writeFrameType(stack[i]);</span>
                }
<span class="nc" id="L676">                break;</span>
            case Opcodes.F_APPEND:
<span class="nc" id="L678">                currentLocals += nLocal;</span>
<span class="nc" id="L679">                stackMap.putByte(SAME_FRAME_EXTENDED + nLocal).putShort(delta);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">                for (int i = 0; i &lt; nLocal; ++i) {</span>
<span class="nc" id="L681">                    writeFrameType(local[i]);</span>
                }
<span class="nc" id="L683">                break;</span>
            case Opcodes.F_CHOP:
<span class="nc" id="L685">                currentLocals -= nLocal;</span>
<span class="nc" id="L686">                stackMap.putByte(SAME_FRAME_EXTENDED - nLocal).putShort(delta);</span>
<span class="nc" id="L687">                break;</span>
            case Opcodes.F_SAME:
<span class="nc bnc" id="L689" title="All 2 branches missed.">                if (delta &lt; 64) {</span>
<span class="nc" id="L690">                    stackMap.putByte(delta);</span>
                } else {
<span class="nc" id="L692">                    stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
                }
<span class="nc" id="L694">                break;</span>
            case Opcodes.F_SAME1:
<span class="nc bnc" id="L696" title="All 2 branches missed.">                if (delta &lt; 64) {</span>
<span class="nc" id="L697">                    stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
                } else {
<span class="nc" id="L699">                    stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)</span>
<span class="nc" id="L700">                            .putShort(delta);</span>
                }
<span class="nc" id="L702">                writeFrameType(stack[0]);</span>
                break;
            }

<span class="nc" id="L706">            previousFrameOffset = code.length;</span>
<span class="nc" id="L707">            ++frameCount;</span>
        }

<span class="nc" id="L710">        maxStack = Math.max(maxStack, nStack);</span>
<span class="nc" id="L711">        maxLocals = Math.max(maxLocals, currentLocals);</span>
<span class="nc" id="L712">    }</span>

    @Override
    public void visitInsn(final int opcode) {
<span class="nc" id="L716">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="nc" id="L718">        code.putByte(opcode);</span>
        // update currentBlock
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L721" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L723">                currentBlock.frame.execute(opcode, 0, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="nc" id="L726">                int size = stackSize + Frame.SIZE[opcode];</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L728">                    maxStackSize = size;</span>
                }
<span class="nc" id="L730">                stackSize = size;</span>
            }
            // if opcode == ATHROW or xRETURN, ends current block (no successor)
<span class="nc bnc" id="L733" title="All 6 branches missed.">            if ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)</span>
                    || opcode == Opcodes.ATHROW) {
<span class="nc" id="L735">                noSuccessor();</span>
            }
        }
<span class="nc" id="L738">    }</span>

    @Override
    public void visitIntInsn(final int opcode, final int operand) {
<span class="nc" id="L742">        lastCodeOffset = code.length;</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L744" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L746">                currentBlock.frame.execute(opcode, operand, null, null);</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">            } else if (opcode != Opcodes.NEWARRAY) {</span>
                // updates current and max stack sizes only for NEWARRAY
                // (stack size variation = 0 for BIPUSH or SIPUSH)
<span class="nc" id="L750">                int size = stackSize + 1;</span>
<span class="nc bnc" id="L751" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L752">                    maxStackSize = size;</span>
                }
<span class="nc" id="L754">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc bnc" id="L758" title="All 2 branches missed.">        if (opcode == Opcodes.SIPUSH) {</span>
<span class="nc" id="L759">            code.put12(opcode, operand);</span>
        } else { // BIPUSH or NEWARRAY
<span class="nc" id="L761">            code.put11(opcode, operand);</span>
        }
<span class="nc" id="L763">    }</span>

    @Override
    public void visitVarInsn(final int opcode, final int var) {
<span class="nc" id="L767">        lastCodeOffset = code.length;</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L769" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L771">                currentBlock.frame.execute(opcode, var, null, null);</span>
            } else {
                // updates current and max stack sizes
<span class="nc bnc" id="L774" title="All 2 branches missed.">                if (opcode == Opcodes.RET) {</span>
                    // no stack change, but end of current block (no successor)
<span class="nc" id="L776">                    currentBlock.status |= Label.RET;</span>
                    // save 'stackSize' here for future use
                    // (see {@link #findSubroutineSuccessors})
<span class="nc" id="L779">                    currentBlock.inputStackTop = stackSize;</span>
<span class="nc" id="L780">                    noSuccessor();</span>
                } else { // xLOAD or xSTORE
<span class="nc" id="L782">                    int size = stackSize + Frame.SIZE[opcode];</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">                    if (size &gt; maxStackSize) {</span>
<span class="nc" id="L784">                        maxStackSize = size;</span>
                    }
<span class="nc" id="L786">                    stackSize = size;</span>
                }
            }
        }
<span class="nc bnc" id="L790" title="All 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
            int n;
<span class="nc bnc" id="L793" title="All 8 branches missed.">            if (opcode == Opcodes.LLOAD || opcode == Opcodes.DLOAD</span>
                    || opcode == Opcodes.LSTORE || opcode == Opcodes.DSTORE) {
<span class="nc" id="L795">                n = var + 2;</span>
            } else {
<span class="nc" id="L797">                n = var + 1;</span>
            }
<span class="nc bnc" id="L799" title="All 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L800">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc bnc" id="L804" title="All 4 branches missed.">        if (var &lt; 4 &amp;&amp; opcode != Opcodes.RET) {</span>
            int opt;
<span class="nc bnc" id="L806" title="All 2 branches missed.">            if (opcode &lt; Opcodes.ISTORE) {</span>
                /* ILOAD_0 */
<span class="nc" id="L808">                opt = 26 + ((opcode - Opcodes.ILOAD) &lt;&lt; 2) + var;</span>
            } else {
                /* ISTORE_0 */
<span class="nc" id="L811">                opt = 59 + ((opcode - Opcodes.ISTORE) &lt;&lt; 2) + var;</span>
            }
<span class="nc" id="L813">            code.putByte(opt);</span>
<span class="nc bnc" id="L814" title="All 2 branches missed.">        } else if (var &gt;= 256) {</span>
<span class="nc" id="L815">            code.putByte(196 /* WIDE */).put12(opcode, var);</span>
        } else {
<span class="nc" id="L817">            code.put11(opcode, var);</span>
        }
<span class="nc bnc" id="L819" title="All 6 branches missed.">        if (opcode &gt;= Opcodes.ISTORE &amp;&amp; compute == FRAMES &amp;&amp; handlerCount &gt; 0) {</span>
<span class="nc" id="L820">            visitLabel(new Label());</span>
        }
<span class="nc" id="L822">    }</span>

    @Override
    public void visitTypeInsn(final int opcode, final String type) {
<span class="nc" id="L826">        lastCodeOffset = code.length;</span>
<span class="nc" id="L827">        Item i = cw.newClassItem(type);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L829" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L831">                currentBlock.frame.execute(opcode, code.length, cw, i);</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">            } else if (opcode == Opcodes.NEW) {</span>
                // updates current and max stack sizes only if opcode == NEW
                // (no stack change for ANEWARRAY, CHECKCAST, INSTANCEOF)
<span class="nc" id="L835">                int size = stackSize + 1;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L837">                    maxStackSize = size;</span>
                }
<span class="nc" id="L839">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L843">        code.put12(opcode, i.index);</span>
<span class="nc" id="L844">    }</span>

    @Override
    public void visitFieldInsn(final int opcode, final String owner,
            final String name, final String desc) {
<span class="nc" id="L849">        lastCodeOffset = code.length;</span>
<span class="nc" id="L850">        Item i = cw.newFieldItem(owner, name, desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L852" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L854">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="nc" id="L858">                char c = desc.charAt(0);</span>
<span class="nc bnc" id="L859" title="All 4 branches missed.">                switch (opcode) {</span>
                case Opcodes.GETSTATIC:
<span class="nc bnc" id="L861" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? 2 : 1);</span>
<span class="nc" id="L862">                    break;</span>
                case Opcodes.PUTSTATIC:
<span class="nc bnc" id="L864" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? -2 : -1);</span>
<span class="nc" id="L865">                    break;</span>
                case Opcodes.GETFIELD:
<span class="nc bnc" id="L867" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? 1 : 0);</span>
<span class="nc" id="L868">                    break;</span>
                // case Constants.PUTFIELD:
                default:
<span class="nc bnc" id="L871" title="All 4 branches missed.">                    size = stackSize + (c == 'D' || c == 'J' ? -3 : -2);</span>
                    break;
                }
                // updates current and max stack sizes
<span class="nc bnc" id="L875" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L876">                    maxStackSize = size;</span>
                }
<span class="nc" id="L878">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L882">        code.put12(opcode, i.index);</span>
<span class="nc" id="L883">    }</span>

    @Override
    public void visitMethodInsn(final int opcode, final String owner,
            final String name, final String desc, final boolean itf) {
<span class="nc" id="L888">        lastCodeOffset = code.length;</span>
<span class="nc" id="L889">        Item i = cw.newMethodItem(owner, name, desc, itf);</span>
<span class="nc" id="L890">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L892" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L894">                currentBlock.frame.execute(opcode, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="nc bnc" id="L904" title="All 2 branches missed.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="nc" id="L907">                    argSize = Type.getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="nc" id="L910">                    i.intVal = argSize;</span>
                }
                int size;
<span class="nc bnc" id="L913" title="All 2 branches missed.">                if (opcode == Opcodes.INVOKESTATIC) {</span>
<span class="nc" id="L914">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>
                } else {
<span class="nc" id="L916">                    size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03);</span>
                }
                // updates current and max stack sizes
<span class="nc bnc" id="L919" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L920">                    maxStackSize = size;</span>
                }
<span class="nc" id="L922">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc bnc" id="L926" title="All 2 branches missed.">        if (opcode == Opcodes.INVOKEINTERFACE) {</span>
<span class="nc bnc" id="L927" title="All 2 branches missed.">            if (argSize == 0) {</span>
<span class="nc" id="L928">                argSize = Type.getArgumentsAndReturnSizes(desc);</span>
<span class="nc" id="L929">                i.intVal = argSize;</span>
            }
<span class="nc" id="L931">            code.put12(Opcodes.INVOKEINTERFACE, i.index).put11(argSize &gt;&gt; 2, 0);</span>
        } else {
<span class="nc" id="L933">            code.put12(opcode, i.index);</span>
        }
<span class="nc" id="L935">    }</span>

    @Override
    public void visitInvokeDynamicInsn(final String name, final String desc,
                                       final Handle bsm, final Object... bsmArgs) {
<span class="nc" id="L940">        lastCodeOffset = code.length;</span>
<span class="nc" id="L941">        Item i = cw.newInvokeDynamicItem(name, desc, bsm, bsmArgs);</span>
<span class="nc" id="L942">        int argSize = i.intVal;</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L944" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L946">                currentBlock.frame.execute(Opcodes.INVOKEDYNAMIC, 0, cw, i);</span>
            } else {
                /*
                 * computes the stack size variation. In order not to recompute
                 * several times this variation for the same Item, we use the
                 * intVal field of this item to store this variation, once it
                 * has been computed. More precisely this intVal field stores
                 * the sizes of the arguments and of the return value
                 * corresponding to desc.
                 */
<span class="nc bnc" id="L956" title="All 2 branches missed.">                if (argSize == 0) {</span>
                    // the above sizes have not been computed yet,
                    // so we compute them...
<span class="nc" id="L959">                    argSize = Type.getArgumentsAndReturnSizes(desc);</span>
                    // ... and we save them in order
                    // not to recompute them in the future
<span class="nc" id="L962">                    i.intVal = argSize;</span>
                }
<span class="nc" id="L964">                int size = stackSize - (argSize &gt;&gt; 2) + (argSize &amp; 0x03) + 1;</span>

                // updates current and max stack sizes
<span class="nc bnc" id="L967" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L968">                    maxStackSize = size;</span>
                }
<span class="nc" id="L970">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L974">        code.put12(Opcodes.INVOKEDYNAMIC, i.index);</span>
<span class="nc" id="L975">        code.putShort(0);</span>
<span class="nc" id="L976">    }</span>

    @Override
    public void visitJumpInsn(final int opcode, final Label label) {
<span class="nc" id="L980">        lastCodeOffset = code.length;</span>
<span class="nc" id="L981">        Label nextInsn = null;</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L983" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L985">                currentBlock.frame.execute(opcode, 0, null, null);</span>
                // 'label' is the target of a jump instruction
<span class="nc" id="L987">                label.getFirst().status |= Label.TARGET;</span>
                // adds 'label' as a successor of this basic block
<span class="nc" id="L989">                addSuccessor(Edge.NORMAL, label);</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">                if (opcode != Opcodes.GOTO) {</span>
                    // creates a Label for the next basic block
<span class="nc" id="L992">                    nextInsn = new Label();</span>
                }
            } else {
<span class="nc bnc" id="L995" title="All 2 branches missed.">                if (opcode == Opcodes.JSR) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">                    if ((label.status &amp; Label.SUBROUTINE) == 0) {</span>
<span class="nc" id="L997">                        label.status |= Label.SUBROUTINE;</span>
<span class="nc" id="L998">                        ++subroutines;</span>
                    }
<span class="nc" id="L1000">                    currentBlock.status |= Label.JSR;</span>
<span class="nc" id="L1001">                    addSuccessor(stackSize + 1, label);</span>
                    // creates a Label for the next basic block
<span class="nc" id="L1003">                    nextInsn = new Label();</span>
                    /*
                     * note that, by construction in this method, a JSR block
                     * has at least two successors in the control flow graph:
                     * the first one leads the next instruction after the JSR,
                     * while the second one leads to the JSR target.
                     */
                } else {
                    // updates current stack size (max stack size unchanged
                    // because stack size variation always negative in this
                    // case)
<span class="nc" id="L1014">                    stackSize += Frame.SIZE[opcode];</span>
<span class="nc" id="L1015">                    addSuccessor(stackSize, label);</span>
                }
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc bnc" id="L1020" title="All 4 branches missed.">        if ((label.status &amp; Label.RESOLVED) != 0</span>
                &amp;&amp; label.position - code.length &lt; Short.MIN_VALUE) {
            /*
             * case of a backward jump with an offset &lt; -32768. In this case we
             * automatically replace GOTO with GOTO_W, JSR with JSR_W and IFxxx
             * &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is the
             * &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ) and where &lt;l'&gt;
             * designates the instruction just after the GOTO_W.
             */
<span class="nc bnc" id="L1029" title="All 2 branches missed.">            if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L1030">                code.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L1032">                code.putByte(201); // JSR_W</span>
            } else {
                // if the IF instruction is transformed into IFNOT GOTO_W the
                // next instruction becomes the target of the IFNOT instruction
<span class="nc bnc" id="L1036" title="All 2 branches missed.">                if (nextInsn != null) {</span>
<span class="nc" id="L1037">                    nextInsn.status |= Label.TARGET;</span>
                }
<span class="nc bnc" id="L1039" title="All 2 branches missed.">                code.putByte(opcode &lt;= 166 ? ((opcode + 1) ^ 1) - 1</span>
                        : opcode ^ 1);
<span class="nc" id="L1041">                code.putShort(8); // jump offset</span>
<span class="nc" id="L1042">                code.putByte(200); // GOTO_W</span>
            }
<span class="nc" id="L1044">            label.put(this, code, code.length - 1, true);</span>
        } else {
            /*
             * case of a backward jump with an offset &gt;= -32768, or of a forward
             * jump with, of course, an unknown offset. In these cases we store
             * the offset in 2 bytes (which will be increased in
             * resizeInstructions, if needed).
             */
<span class="nc" id="L1052">            code.putByte(opcode);</span>
<span class="nc" id="L1053">            label.put(this, code, code.length - 1, false);</span>
        }
<span class="nc bnc" id="L1055" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if (nextInsn != null) {</span>
                // if the jump instruction is not a GOTO, the next instruction
                // is also a successor of this instruction. Calling visitLabel
                // adds the label of this next instruction as a successor of the
                // current block, and starts a new basic block
<span class="nc" id="L1061">                visitLabel(nextInsn);</span>
            }
<span class="nc bnc" id="L1063" title="All 2 branches missed.">            if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L1064">                noSuccessor();</span>
            }
        }
<span class="nc" id="L1067">    }</span>

    @Override
    public void visitLabel(final Label label) {
        // resolves previous forward references to label, if any
<span class="nc" id="L1072">        resize |= label.resolve(this, code.length, code.data);</span>
        // updates currentBlock
<span class="nc bnc" id="L1074" title="All 2 branches missed.">        if ((label.status &amp; Label.DEBUG) != 0) {</span>
<span class="nc" id="L1075">            return;</span>
        }
<span class="nc bnc" id="L1077" title="All 2 branches missed.">        if (compute == FRAMES) {</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">            if (currentBlock != null) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">                if (label.position == currentBlock.position) {</span>
                    // successive labels, do not start a new basic block
<span class="nc" id="L1081">                    currentBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="nc" id="L1082">                    label.frame = currentBlock.frame;</span>
<span class="nc" id="L1083">                    return;</span>
                }
                // ends current block (with one new successor)
<span class="nc" id="L1086">                addSuccessor(Edge.NORMAL, label);</span>
            }
            // begins a new current block
<span class="nc" id="L1089">            currentBlock = label;</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">            if (label.frame == null) {</span>
<span class="nc" id="L1091">                label.frame = new Frame();</span>
<span class="nc" id="L1092">                label.frame.owner = label;</span>
            }
            // updates the basic block list
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            if (previousBlock != null) {</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">                if (label.position == previousBlock.position) {</span>
<span class="nc" id="L1097">                    previousBlock.status |= (label.status &amp; Label.TARGET);</span>
<span class="nc" id="L1098">                    label.frame = previousBlock.frame;</span>
<span class="nc" id="L1099">                    currentBlock = previousBlock;</span>
<span class="nc" id="L1100">                    return;</span>
                }
<span class="nc" id="L1102">                previousBlock.successor = label;</span>
            }
<span class="nc" id="L1104">            previousBlock = label;</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">        } else if (compute == MAXS) {</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">            if (currentBlock != null) {</span>
                // ends current block (with one new successor)
<span class="nc" id="L1108">                currentBlock.outputStackMax = maxStackSize;</span>
<span class="nc" id="L1109">                addSuccessor(stackSize, label);</span>
            }
            // begins a new current block
<span class="nc" id="L1112">            currentBlock = label;</span>
            // resets the relative current and max stack sizes
<span class="nc" id="L1114">            stackSize = 0;</span>
<span class="nc" id="L1115">            maxStackSize = 0;</span>
            // updates the basic block list
<span class="nc bnc" id="L1117" title="All 2 branches missed.">            if (previousBlock != null) {</span>
<span class="nc" id="L1118">                previousBlock.successor = label;</span>
            }
<span class="nc" id="L1120">            previousBlock = label;</span>
        }
<span class="nc" id="L1122">    }</span>

    @Override
    public void visitLdcInsn(final Object cst) {
<span class="nc" id="L1126">        lastCodeOffset = code.length;</span>
<span class="nc" id="L1127">        Item i = cw.newConstItem(cst);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L1129" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1131">                currentBlock.frame.execute(Opcodes.LDC, 0, cw, i);</span>
            } else {
                int size;
                // computes the stack size variation
<span class="nc bnc" id="L1135" title="All 4 branches missed.">                if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="nc" id="L1136">                    size = stackSize + 2;</span>
                } else {
<span class="nc" id="L1138">                    size = stackSize + 1;</span>
                }
                // updates current and max stack sizes
<span class="nc bnc" id="L1141" title="All 2 branches missed.">                if (size &gt; maxStackSize) {</span>
<span class="nc" id="L1142">                    maxStackSize = size;</span>
                }
<span class="nc" id="L1144">                stackSize = size;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1148">        int index = i.index;</span>
<span class="nc bnc" id="L1149" title="All 4 branches missed.">        if (i.type == ClassWriter.LONG || i.type == ClassWriter.DOUBLE) {</span>
<span class="nc" id="L1150">            code.put12(20 /* LDC2_W */, index);</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">        } else if (index &gt;= 256) {</span>
<span class="nc" id="L1152">            code.put12(19 /* LDC_W */, index);</span>
        } else {
<span class="nc" id="L1154">            code.put11(Opcodes.LDC, index);</span>
        }
<span class="nc" id="L1156">    }</span>

    @Override
    public void visitIincInsn(final int var, final int increment) {
<span class="nc" id="L1160">        lastCodeOffset = code.length;</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1163">                currentBlock.frame.execute(Opcodes.IINC, var, null, null);</span>
            }
        }
<span class="nc bnc" id="L1166" title="All 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="nc" id="L1168">            int n = var + 1;</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L1170">                maxLocals = n;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc bnc" id="L1174" title="All 6 branches missed.">        if ((var &gt; 255) || (increment &gt; 127) || (increment &lt; -128)) {</span>
<span class="nc" id="L1175">            code.putByte(196 /* WIDE */).put12(Opcodes.IINC, var)</span>
<span class="nc" id="L1176">                    .putShort(increment);</span>
        } else {
<span class="nc" id="L1178">            code.putByte(Opcodes.IINC).put11(var, increment);</span>
        }
<span class="nc" id="L1180">    }</span>

    @Override
    public void visitTableSwitchInsn(final int min, final int max,
                                     final Label dflt, final Label... labels) {
<span class="nc" id="L1185">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1187">        int source = code.length;</span>
<span class="nc" id="L1188">        code.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L1189">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="nc" id="L1190">        dflt.put(this, code, source, true);</span>
<span class="nc" id="L1191">        code.putInt(min).putInt(max);</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1193">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="nc" id="L1196">        visitSwitchInsn(dflt, labels);</span>
<span class="nc" id="L1197">    }</span>

    @Override
    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
                                      final Label[] labels) {
<span class="nc" id="L1202">        lastCodeOffset = code.length;</span>
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1204">        int source = code.length;</span>
<span class="nc" id="L1205">        code.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L1206">        code.putByteArray(null, 0, (4 - code.length % 4) % 4);</span>
<span class="nc" id="L1207">        dflt.put(this, code, source, true);</span>
<span class="nc" id="L1208">        code.putInt(labels.length);</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1210">            code.putInt(keys[i]);</span>
<span class="nc" id="L1211">            labels[i].put(this, code, source, true);</span>
        }
        // updates currentBlock
<span class="nc" id="L1214">        visitSwitchInsn(dflt, labels);</span>
<span class="nc" id="L1215">    }</span>

    private void visitSwitchInsn(final Label dflt, final Label[] labels) {
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1221">                currentBlock.frame.execute(Opcodes.LOOKUPSWITCH, 0, null, null);</span>
                // adds current block successors
<span class="nc" id="L1223">                addSuccessor(Edge.NORMAL, dflt);</span>
<span class="nc" id="L1224">                dflt.getFirst().status |= Label.TARGET;</span>
<span class="nc bnc" id="L1225" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1226">                    addSuccessor(Edge.NORMAL, labels[i]);</span>
<span class="nc" id="L1227">                    labels[i].getFirst().status |= Label.TARGET;</span>
                }
            } else {
                // updates current stack size (max stack size unchanged)
<span class="nc" id="L1231">                --stackSize;</span>
                // adds current block successors
<span class="nc" id="L1233">                addSuccessor(stackSize, dflt);</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">                for (int i = 0; i &lt; labels.length; ++i) {</span>
<span class="nc" id="L1235">                    addSuccessor(stackSize, labels[i]);</span>
                }
            }
            // ends current block
<span class="nc" id="L1239">            noSuccessor();</span>
        }
<span class="nc" id="L1241">    }</span>

    @Override
    public void visitMultiANewArrayInsn(final String desc, final int dims) {
<span class="nc" id="L1245">        lastCodeOffset = code.length;</span>
<span class="nc" id="L1246">        Item i = cw.newClassItem(desc);</span>
        // Label currentBlock = this.currentBlock;
<span class="nc bnc" id="L1248" title="All 2 branches missed.">        if (currentBlock != null) {</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            if (compute == FRAMES) {</span>
<span class="nc" id="L1250">                currentBlock.frame.execute(Opcodes.MULTIANEWARRAY, dims, cw, i);</span>
            } else {
                // updates current stack size (max stack size unchanged because
                // stack size variation always negative or null)
<span class="nc" id="L1254">                stackSize += 1 - dims;</span>
            }
        }
        // adds the instruction to the bytecode of the method
<span class="nc" id="L1258">        code.put12(Opcodes.MULTIANEWARRAY, i.index).putByte(dims);</span>
<span class="nc" id="L1259">    }</span>

    @Override
    public AnnotationVisitor visitInsnAnnotation(int typeRef,
                                                                 TypePath typePath, String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1267">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1269">        typeRef = (typeRef &amp; 0xFF0000FF) | (lastCodeOffset &lt;&lt; 8);</span>
<span class="nc" id="L1270">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L1272">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1273">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1275" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1276">            aw.next = ctanns;</span>
<span class="nc" id="L1277">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1279">            aw.next = ictanns;</span>
<span class="nc" id="L1280">            ictanns = aw;</span>
        }
<span class="nc" id="L1282">        return aw;</span>
    }

    @Override
    public void visitTryCatchBlock(final Label start, final Label end,
                                   final Label handler, final String type) {
<span class="nc" id="L1288">        ++handlerCount;</span>
<span class="nc" id="L1289">        Handler h = new Handler();</span>
<span class="nc" id="L1290">        h.start = start;</span>
<span class="nc" id="L1291">        h.end = end;</span>
<span class="nc" id="L1292">        h.handler = handler;</span>
<span class="nc" id="L1293">        h.desc = type;</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">        h.type = type != null ? cw.newClass(type) : 0;</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">        if (lastHandler == null) {</span>
<span class="nc" id="L1296">            firstHandler = h;</span>
        } else {
<span class="nc" id="L1298">            lastHandler.next = h;</span>
        }
<span class="nc" id="L1300">        lastHandler = h;</span>
<span class="nc" id="L1301">    }</span>

    @Override
    public AnnotationVisitor visitTryCatchAnnotation(int typeRef,
                                                                     TypePath typePath, String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1309">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1311">        AnnotationWriter.putTarget(typeRef, typePath, bv);</span>
        // write type, and reserve space for values count
<span class="nc" id="L1313">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1314">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1316" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1317">            aw.next = ctanns;</span>
<span class="nc" id="L1318">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1320">            aw.next = ictanns;</span>
<span class="nc" id="L1321">            ictanns = aw;</span>
        }
<span class="nc" id="L1323">        return aw;</span>
    }

    @Override
    public void visitLocalVariable(final String name, final String desc,
                                   final String signature, final Label start, final Label end,
                                   final int index) {
<span class="nc bnc" id="L1330" title="All 2 branches missed.">        if (signature != null) {</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">            if (localVarType == null) {</span>
<span class="nc" id="L1332">                localVarType = new ByteVector();</span>
            }
<span class="nc" id="L1334">            ++localVarTypeCount;</span>
<span class="nc" id="L1335">            localVarType.putShort(start.position)</span>
<span class="nc" id="L1336">                    .putShort(end.position - start.position)</span>
<span class="nc" id="L1337">                    .putShort(cw.newUTF8(name)).putShort(cw.newUTF8(signature))</span>
<span class="nc" id="L1338">                    .putShort(index);</span>
        }
<span class="nc bnc" id="L1340" title="All 2 branches missed.">        if (localVar == null) {</span>
<span class="nc" id="L1341">            localVar = new ByteVector();</span>
        }
<span class="nc" id="L1343">        ++localVarCount;</span>
<span class="nc" id="L1344">        localVar.putShort(start.position)</span>
<span class="nc" id="L1345">                .putShort(end.position - start.position)</span>
<span class="nc" id="L1346">                .putShort(cw.newUTF8(name)).putShort(cw.newUTF8(desc))</span>
<span class="nc" id="L1347">                .putShort(index);</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">        if (compute != NOTHING) {</span>
            // updates max locals
<span class="nc" id="L1350">            char c = desc.charAt(0);</span>
<span class="nc bnc" id="L1351" title="All 4 branches missed.">            int n = index + (c == 'J' || c == 'D' ? 2 : 1);</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">            if (n &gt; maxLocals) {</span>
<span class="nc" id="L1353">                maxLocals = n;</span>
            }
        }
<span class="nc" id="L1356">    }</span>

    @Override
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
                                                          TypePath typePath, Label[] start, Label[] end, int[] index,
                                                          String desc, boolean visible) {
        if (!ClassReader.ANNOTATIONS) {
            return null;
        }
<span class="nc" id="L1365">        ByteVector bv = new ByteVector();</span>
        // write target_type and target_info
<span class="nc" id="L1367">        bv.putByte(typeRef &gt;&gt;&gt; 24).putShort(start.length);</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">        for (int i = 0; i &lt; start.length; ++i) {</span>
<span class="nc" id="L1369">            bv.putShort(start[i].position)</span>
<span class="nc" id="L1370">                    .putShort(end[i].position - start[i].position)</span>
<span class="nc" id="L1371">                    .putShort(index[i]);</span>
        }
<span class="nc bnc" id="L1373" title="All 2 branches missed.">        if (typePath == null) {</span>
<span class="nc" id="L1374">            bv.putByte(0);</span>
        } else {
<span class="nc" id="L1376">            int length = typePath.b[typePath.offset] * 2 + 1;</span>
<span class="nc" id="L1377">            bv.putByteArray(typePath.b, typePath.offset, length);</span>
        }
        // write type, and reserve space for values count
<span class="nc" id="L1380">        bv.putShort(cw.newUTF8(desc)).putShort(0);</span>
<span class="nc" id="L1381">        AnnotationWriter aw = new AnnotationWriter(cw, true, bv, bv,</span>
                bv.length - 2);
<span class="nc bnc" id="L1383" title="All 2 branches missed.">        if (visible) {</span>
<span class="nc" id="L1384">            aw.next = ctanns;</span>
<span class="nc" id="L1385">            ctanns = aw;</span>
        } else {
<span class="nc" id="L1387">            aw.next = ictanns;</span>
<span class="nc" id="L1388">            ictanns = aw;</span>
        }
<span class="nc" id="L1390">        return aw;</span>
    }

    @Override
    public void visitLineNumber(final int line, final Label start) {
<span class="nc bnc" id="L1395" title="All 2 branches missed.">        if (lineNumber == null) {</span>
<span class="nc" id="L1396">            lineNumber = new ByteVector();</span>
        }
<span class="nc" id="L1398">        ++lineNumberCount;</span>
<span class="nc" id="L1399">        lineNumber.putShort(start.position);</span>
<span class="nc" id="L1400">        lineNumber.putShort(line);</span>
<span class="nc" id="L1401">    }</span>

    @Override
    public void visitMaxs(final int maxStack, final int maxLocals) {
<span class="nc bnc" id="L1405" title="All 2 branches missed.">        if (resize) {</span>
            // replaces the temporary jump opcodes introduced by Label.resolve.
            if (ClassReader.RESIZE) {
<span class="nc" id="L1408">                resizeInstructions();</span>
            } else {
                throw new RuntimeException(&quot;Method code too large!&quot;);
            }
        }
<span class="nc bnc" id="L1413" title="All 2 branches missed.">        if (ClassReader.FRAMES &amp;&amp; compute == FRAMES) {</span>
            // completes the control flow graph with exception handler blocks
<span class="nc" id="L1415">            Handler handler = firstHandler;</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1417">                Label l = handler.start.getFirst();</span>
<span class="nc" id="L1418">                Label h = handler.handler.getFirst();</span>
<span class="nc" id="L1419">                Label e = handler.end.getFirst();</span>
                // computes the kind of the edges to 'h'
<span class="nc bnc" id="L1421" title="All 2 branches missed.">                String t = handler.desc == null ? &quot;java/lang/Throwable&quot;</span>
                        : handler.desc;
<span class="nc" id="L1423">                int kind = Frame.OBJECT | cw.addType(t);</span>
                // h is an exception handler
<span class="nc" id="L1425">                h.status |= Label.TARGET;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="nc bnc" id="L1427" title="All 2 branches missed.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="nc" id="L1429">                    Edge b = new Edge();</span>
<span class="nc" id="L1430">                    b.info = kind;</span>
<span class="nc" id="L1431">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="nc" id="L1433">                    b.next = l.successors;</span>
<span class="nc" id="L1434">                    l.successors = b;</span>
                    // goes to the next label
<span class="nc" id="L1436">                    l = l.successor;</span>
<span class="nc" id="L1437">                }</span>
<span class="nc" id="L1438">                handler = handler.next;</span>
<span class="nc" id="L1439">            }</span>

            // creates and visits the first (implicit) frame
<span class="nc" id="L1442">            Frame f = labels.frame;</span>
<span class="nc" id="L1443">            Type[] args = Type.getArgumentTypes(descriptor);</span>
<span class="nc" id="L1444">            f.initInputFrame(cw, access, args, this.maxLocals);</span>
<span class="nc" id="L1445">            visitFrame(f);</span>

            /*
             * fix point algorithm: mark the first basic block as 'changed'
             * (i.e. put it in the 'changed' list) and, while there are changed
             * basic blocks, choose one, mark it as unchanged, and update its
             * successors (which can be changed in the process).
             */
<span class="nc" id="L1453">            int max = 0;</span>
<span class="nc" id="L1454">            Label changed = labels;</span>
<span class="nc bnc" id="L1455" title="All 2 branches missed.">            while (changed != null) {</span>
                // removes a basic block from the list of changed basic blocks
<span class="nc" id="L1457">                Label l = changed;</span>
<span class="nc" id="L1458">                changed = changed.next;</span>
<span class="nc" id="L1459">                l.next = null;</span>
<span class="nc" id="L1460">                f = l.frame;</span>
                // a reachable jump target must be stored in the stack map
<span class="nc bnc" id="L1462" title="All 2 branches missed.">                if ((l.status &amp; Label.TARGET) != 0) {</span>
<span class="nc" id="L1463">                    l.status |= Label.STORE;</span>
                }
                // all visited labels are reachable, by definition
<span class="nc" id="L1466">                l.status |= Label.REACHABLE;</span>
                // updates the (absolute) maximum stack size
<span class="nc" id="L1468">                int blockMax = f.inputStack.length + l.outputStackMax;</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">                if (blockMax &gt; max) {</span>
<span class="nc" id="L1470">                    max = blockMax;</span>
                }
                // updates the successors of the current basic block
<span class="nc" id="L1473">                Edge e = l.successors;</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">                while (e != null) {</span>
<span class="nc" id="L1475">                    Label n = e.successor.getFirst();</span>
<span class="nc" id="L1476">                    boolean change = f.merge(cw, n.frame, e.info);</span>
<span class="nc bnc" id="L1477" title="All 4 branches missed.">                    if (change &amp;&amp; n.next == null) {</span>
                        // if n has changed and is not already in the 'changed'
                        // list, adds it to this list
<span class="nc" id="L1480">                        n.next = changed;</span>
<span class="nc" id="L1481">                        changed = n;</span>
                    }
<span class="nc" id="L1483">                    e = e.next;</span>
<span class="nc" id="L1484">                }</span>
<span class="nc" id="L1485">            }</span>

            // visits all the frames that must be stored in the stack map
<span class="nc" id="L1488">            Label l = labels;</span>
<span class="nc bnc" id="L1489" title="All 2 branches missed.">            while (l != null) {</span>
<span class="nc" id="L1490">                f = l.frame;</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">                if ((l.status &amp; Label.STORE) != 0) {</span>
<span class="nc" id="L1492">                    visitFrame(f);</span>
                }
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                if ((l.status &amp; Label.REACHABLE) == 0) {</span>
                    // finds start and end of dead basic block
<span class="nc" id="L1496">                    Label k = l.successor;</span>
<span class="nc" id="L1497">                    int start = l.position;</span>
<span class="nc bnc" id="L1498" title="All 2 branches missed.">                    int end = (k == null ? code.length : k.position) - 1;</span>
                    // if non empty basic block
<span class="nc bnc" id="L1500" title="All 2 branches missed.">                    if (end &gt;= start) {</span>
<span class="nc" id="L1501">                        max = Math.max(max, 1);</span>
                        // replaces instructions with NOP ... NOP ATHROW
<span class="nc bnc" id="L1503" title="All 2 branches missed.">                        for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1504">                            code.data[i] = Opcodes.NOP;</span>
                        }
<span class="nc" id="L1506">                        code.data[end] = (byte) Opcodes.ATHROW;</span>
                        // emits a frame for this unreachable block
<span class="nc" id="L1508">                        int frameIndex = startFrame(start, 0, 1);</span>
<span class="nc" id="L1509">                        frame[frameIndex] = Frame.OBJECT</span>
<span class="nc" id="L1510">                                | cw.addType(&quot;java/lang/Throwable&quot;);</span>
<span class="nc" id="L1511">                        endFrame();</span>
                        // removes the start-end range from the exception
                        // handlers
<span class="nc" id="L1514">                        firstHandler = Handler.remove(firstHandler, l, k);</span>
                    }
                }
<span class="nc" id="L1517">                l = l.successor;</span>
            }

<span class="nc" id="L1520">            handler = firstHandler;</span>
<span class="nc" id="L1521">            handlerCount = 0;</span>
<span class="nc bnc" id="L1522" title="All 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1523">                handlerCount += 1;</span>
<span class="nc" id="L1524">                handler = handler.next;</span>
            }

<span class="nc" id="L1527">            this.maxStack = max;</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">        } else if (compute == MAXS) {</span>
            // completes the control flow graph with exception handler blocks
<span class="nc" id="L1530">            Handler handler = firstHandler;</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">            while (handler != null) {</span>
<span class="nc" id="L1532">                Label l = handler.start;</span>
<span class="nc" id="L1533">                Label h = handler.handler;</span>
<span class="nc" id="L1534">                Label e = handler.end;</span>
                // adds 'h' as a successor of labels between 'start' and 'end'
<span class="nc bnc" id="L1536" title="All 2 branches missed.">                while (l != e) {</span>
                    // creates an edge to 'h'
<span class="nc" id="L1538">                    Edge b = new Edge();</span>
<span class="nc" id="L1539">                    b.info = Edge.EXCEPTION;</span>
<span class="nc" id="L1540">                    b.successor = h;</span>
                    // adds it to the successors of 'l'
<span class="nc bnc" id="L1542" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) == 0) {</span>
<span class="nc" id="L1543">                        b.next = l.successors;</span>
<span class="nc" id="L1544">                        l.successors = b;</span>
                    } else {
                        // if l is a JSR block, adds b after the first two edges
                        // to preserve the hypothesis about JSR block successors
                        // order (see {@link #visitJumpInsn})
<span class="nc" id="L1549">                        b.next = l.successors.next.next;</span>
<span class="nc" id="L1550">                        l.successors.next.next = b;</span>
                    }
                    // goes to the next label
<span class="nc" id="L1553">                    l = l.successor;</span>
<span class="nc" id="L1554">                }</span>
<span class="nc" id="L1555">                handler = handler.next;</span>
<span class="nc" id="L1556">            }</span>

<span class="nc bnc" id="L1558" title="All 2 branches missed.">            if (subroutines &gt; 0) {</span>
                // completes the control flow graph with the RET successors
                /*
                 * first step: finds the subroutines. This step determines, for
                 * each basic block, to which subroutine(s) it belongs.
                 */
                // finds the basic blocks that belong to the &quot;main&quot; subroutine
<span class="nc" id="L1565">                int id = 0;</span>
<span class="nc" id="L1566">                labels.visitSubroutine(null, 1, subroutines);</span>
                // finds the basic blocks that belong to the real subroutines
<span class="nc" id="L1568">                Label l = labels;</span>
<span class="nc bnc" id="L1569" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1572">                        Label subroutine = l.successors.next.successor;</span>
                        // if this subroutine has not been visited yet...
<span class="nc bnc" id="L1574" title="All 2 branches missed.">                        if ((subroutine.status &amp; Label.VISITED) == 0) {</span>
                            // ...assigns it a new id and finds its basic blocks
<span class="nc" id="L1576">                            id += 1;</span>
<span class="nc" id="L1577">                            subroutine.visitSubroutine(null, (id / 32L) &lt;&lt; 32</span>
                                    | (1L &lt;&lt; (id % 32)), subroutines);
                        }
                    }
<span class="nc" id="L1581">                    l = l.successor;</span>
                }
                // second step: finds the successors of RET blocks
<span class="nc" id="L1584">                l = labels;</span>
<span class="nc bnc" id="L1585" title="All 2 branches missed.">                while (l != null) {</span>
<span class="nc bnc" id="L1586" title="All 2 branches missed.">                    if ((l.status &amp; Label.JSR) != 0) {</span>
<span class="nc" id="L1587">                        Label L = labels;</span>
<span class="nc bnc" id="L1588" title="All 2 branches missed.">                        while (L != null) {</span>
<span class="nc" id="L1589">                            L.status &amp;= ~Label.VISITED2;</span>
<span class="nc" id="L1590">                            L = L.successor;</span>
                        }
                        // the subroutine is defined by l's TARGET, not by l
<span class="nc" id="L1593">                        Label subroutine = l.successors.next.successor;</span>
<span class="nc" id="L1594">                        subroutine.visitSubroutine(l, 0, subroutines);</span>
                    }
<span class="nc" id="L1596">                    l = l.successor;</span>
                }
            }

            /*
             * control flow analysis algorithm: while the block stack is not
             * empty, pop a block from this stack, update the max stack size,
             * compute the true (non relative) begin stack size of the
             * successors of this block, and push these successors onto the
             * stack (unless they have already been pushed onto the stack).
             * Note: by hypothesis, the {@link Label#inputStackTop} of the
             * blocks in the block stack are the true (non relative) beginning
             * stack sizes of these blocks.
             */
<span class="nc" id="L1610">            int max = 0;</span>
<span class="nc" id="L1611">            Label stack = labels;</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">            while (stack != null) {</span>
                // pops a block from the stack
<span class="nc" id="L1614">                Label l = stack;</span>
<span class="nc" id="L1615">                stack = stack.next;</span>
                // computes the true (non relative) max stack size of this block
<span class="nc" id="L1617">                int start = l.inputStackTop;</span>
<span class="nc" id="L1618">                int blockMax = start + l.outputStackMax;</span>
                // updates the global max stack size
<span class="nc bnc" id="L1620" title="All 2 branches missed.">                if (blockMax &gt; max) {</span>
<span class="nc" id="L1621">                    max = blockMax;</span>
                }
                // analyzes the successors of the block
<span class="nc" id="L1624">                Edge b = l.successors;</span>
<span class="nc bnc" id="L1625" title="All 2 branches missed.">                if ((l.status &amp; Label.JSR) != 0) {</span>
                    // ignores the first edge of JSR blocks (virtual successor)
<span class="nc" id="L1627">                    b = b.next;</span>
                }
<span class="nc bnc" id="L1629" title="All 2 branches missed.">                while (b != null) {</span>
<span class="nc" id="L1630">                    l = b.successor;</span>
                    // if this successor has not already been pushed...
<span class="nc bnc" id="L1632" title="All 2 branches missed.">                    if ((l.status &amp; Label.PUSHED) == 0) {</span>
                        // computes its true beginning stack size...
<span class="nc bnc" id="L1634" title="All 2 branches missed.">                        l.inputStackTop = b.info == Edge.EXCEPTION ? 1 : start</span>
                                + b.info;
                        // ...and pushes it onto the stack
<span class="nc" id="L1637">                        l.status |= Label.PUSHED;</span>
<span class="nc" id="L1638">                        l.next = stack;</span>
<span class="nc" id="L1639">                        stack = l;</span>
                    }
<span class="nc" id="L1641">                    b = b.next;</span>
                }
<span class="nc" id="L1643">            }</span>
<span class="nc" id="L1644">            this.maxStack = Math.max(maxStack, max);</span>
<span class="nc" id="L1645">        } else {</span>
<span class="nc" id="L1646">            this.maxStack = maxStack;</span>
<span class="nc" id="L1647">            this.maxLocals = maxLocals;</span>
        }
<span class="nc" id="L1649">    }</span>

    @Override
    public void visitEnd() {
<span class="nc" id="L1653">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: control flow analysis algorithm
    // ------------------------------------------------------------------------

    /**
     * Adds a successor to the {@link #currentBlock currentBlock} block.
     *
     * @param info
     *            information about the control flow edge to be added.
     * @param successor
     *            the successor block to be added to the current block.
     */
    private void addSuccessor(final int info, final Label successor) {
        // creates and initializes an Edge object...
<span class="nc" id="L1669">        Edge b = new Edge();</span>
<span class="nc" id="L1670">        b.info = info;</span>
<span class="nc" id="L1671">        b.successor = successor;</span>
        // ...and adds it to the successor list of the currentBlock block
<span class="nc" id="L1673">        b.next = currentBlock.successors;</span>
<span class="nc" id="L1674">        currentBlock.successors = b;</span>
<span class="nc" id="L1675">    }</span>

    /**
     * Ends the current basic block. This method must be used in the case where
     * the current basic block does not have any successor.
     */
    private void noSuccessor() {
<span class="nc bnc" id="L1682" title="All 2 branches missed.">        if (compute == FRAMES) {</span>
<span class="nc" id="L1683">            Label l = new Label();</span>
<span class="nc" id="L1684">            l.frame = new Frame();</span>
<span class="nc" id="L1685">            l.frame.owner = l;</span>
<span class="nc" id="L1686">            l.resolve(this, code.length, code.data);</span>
<span class="nc" id="L1687">            previousBlock.successor = l;</span>
<span class="nc" id="L1688">            previousBlock = l;</span>
<span class="nc" id="L1689">        } else {</span>
<span class="nc" id="L1690">            currentBlock.outputStackMax = maxStackSize;</span>
        }
<span class="nc" id="L1692">        currentBlock = null;</span>
<span class="nc" id="L1693">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: stack map frames
    // ------------------------------------------------------------------------

    /**
     * Visits a frame that has been computed from scratch.
     *
     * @param f
     *            the frame that must be visited.
     */
    private void visitFrame(final Frame f) {
        int i, t;
<span class="nc" id="L1707">        int nTop = 0;</span>
<span class="nc" id="L1708">        int nLocal = 0;</span>
<span class="nc" id="L1709">        int nStack = 0;</span>
<span class="nc" id="L1710">        int[] locals = f.inputLocals;</span>
<span class="nc" id="L1711">        int[] stacks = f.inputStack;</span>
        // computes the number of locals (ignores TOP types that are just after
        // a LONG or a DOUBLE, and all trailing TOP types)
<span class="nc bnc" id="L1714" title="All 2 branches missed.">        for (i = 0; i &lt; locals.length; ++i) {</span>
<span class="nc" id="L1715">            t = locals[i];</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">            if (t == Frame.TOP) {</span>
<span class="nc" id="L1717">                ++nTop;</span>
            } else {
<span class="nc" id="L1719">                nLocal += nTop + 1;</span>
<span class="nc" id="L1720">                nTop = 0;</span>
            }
<span class="nc bnc" id="L1722" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1723">                ++i;</span>
            }
        }
        // computes the stack size (ignores TOP types that are just after
        // a LONG or a DOUBLE)
<span class="nc bnc" id="L1728" title="All 2 branches missed.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="nc" id="L1729">            t = stacks[i];</span>
<span class="nc" id="L1730">            ++nStack;</span>
<span class="nc bnc" id="L1731" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1732">                ++i;</span>
            }
        }
        // visits the frame and its content
<span class="nc" id="L1736">        int frameIndex = startFrame(f.owner.position, nLocal, nStack);</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">        for (i = 0; nLocal &gt; 0; ++i, --nLocal) {</span>
<span class="nc" id="L1738">            t = locals[i];</span>
<span class="nc" id="L1739">            frame[frameIndex++] = t;</span>
<span class="nc bnc" id="L1740" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1741">                ++i;</span>
            }
        }
<span class="nc bnc" id="L1744" title="All 2 branches missed.">        for (i = 0; i &lt; stacks.length; ++i) {</span>
<span class="nc" id="L1745">            t = stacks[i];</span>
<span class="nc" id="L1746">            frame[frameIndex++] = t;</span>
<span class="nc bnc" id="L1747" title="All 4 branches missed.">            if (t == Frame.LONG || t == Frame.DOUBLE) {</span>
<span class="nc" id="L1748">                ++i;</span>
            }
        }
<span class="nc" id="L1751">        endFrame();</span>
<span class="nc" id="L1752">    }</span>

    /**
     * Visit the implicit first frame of this method.
     */
    private void visitImplicitFirstFrame() {
        // There can be at most descriptor.length() + 1 locals
<span class="nc" id="L1759">        int frameIndex = startFrame(0, descriptor.length() + 1, 0);</span>
<span class="nc bnc" id="L1760" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_STATIC) == 0) {</span>
<span class="nc bnc" id="L1761" title="All 2 branches missed.">            if ((access &amp; ACC_CONSTRUCTOR) == 0) {</span>
<span class="nc" id="L1762">                frame[frameIndex++] = Frame.OBJECT | cw.addType(cw.thisName);</span>
            } else {
<span class="nc" id="L1764">                frame[frameIndex++] = 6; // Opcodes.UNINITIALIZED_THIS;</span>
            }
        }
<span class="nc" id="L1767">        int i = 1;</span>
        loop: while (true) {
<span class="nc" id="L1769">            int j = i;</span>
<span class="nc bnc" id="L1770" title="All 7 branches missed.">            switch (descriptor.charAt(i++)) {</span>
            case 'Z':
            case 'C':
            case 'B':
            case 'S':
            case 'I':
<span class="nc" id="L1776">                frame[frameIndex++] = 1; // Opcodes.INTEGER;</span>
<span class="nc" id="L1777">                break;</span>
            case 'F':
<span class="nc" id="L1779">                frame[frameIndex++] = 2; // Opcodes.FLOAT;</span>
<span class="nc" id="L1780">                break;</span>
            case 'J':
<span class="nc" id="L1782">                frame[frameIndex++] = 4; // Opcodes.LONG;</span>
<span class="nc" id="L1783">                break;</span>
            case 'D':
<span class="nc" id="L1785">                frame[frameIndex++] = 3; // Opcodes.DOUBLE;</span>
<span class="nc" id="L1786">                break;</span>
            case '[':
<span class="nc bnc" id="L1788" title="All 2 branches missed.">                while (descriptor.charAt(i) == '[') {</span>
<span class="nc" id="L1789">                    ++i;</span>
                }
<span class="nc bnc" id="L1791" title="All 2 branches missed.">                if (descriptor.charAt(i) == 'L') {</span>
<span class="nc" id="L1792">                    ++i;</span>
<span class="nc bnc" id="L1793" title="All 2 branches missed.">                    while (descriptor.charAt(i) != ';') {</span>
<span class="nc" id="L1794">                        ++i;</span>
                    }
                }
<span class="nc" id="L1797">                frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1798">                        | cw.addType(descriptor.substring(j, ++i));</span>
<span class="nc" id="L1799">                break;</span>
            case 'L':
<span class="nc bnc" id="L1801" title="All 2 branches missed.">                while (descriptor.charAt(i) != ';') {</span>
<span class="nc" id="L1802">                    ++i;</span>
                }
<span class="nc" id="L1804">                frame[frameIndex++] = Frame.OBJECT</span>
<span class="nc" id="L1805">                        | cw.addType(descriptor.substring(j + 1, i++));</span>
<span class="nc" id="L1806">                break;</span>
            default:
<span class="nc" id="L1808">                break loop;</span>
            }
<span class="nc" id="L1810">        }</span>
<span class="nc" id="L1811">        frame[1] = frameIndex - 3;</span>
<span class="nc" id="L1812">        endFrame();</span>
<span class="nc" id="L1813">    }</span>

    /**
     * Starts the visit of a stack map frame.
     *
     * @param offset
     *            the offset of the instruction to which the frame corresponds.
     * @param nLocal
     *            the number of local variables in the frame.
     * @param nStack
     *            the number of stack elements in the frame.
     * @return the index of the next element to be written in this frame.
     */
    private int startFrame(final int offset, final int nLocal, final int nStack) {
<span class="nc" id="L1827">        int n = 3 + nLocal + nStack;</span>
<span class="nc bnc" id="L1828" title="All 4 branches missed.">        if (frame == null || frame.length &lt; n) {</span>
<span class="nc" id="L1829">            frame = new int[n];</span>
        }
<span class="nc" id="L1831">        frame[0] = offset;</span>
<span class="nc" id="L1832">        frame[1] = nLocal;</span>
<span class="nc" id="L1833">        frame[2] = nStack;</span>
<span class="nc" id="L1834">        return 3;</span>
    }

    /**
     * Checks if the visit of the current frame {@link #frame} is finished, and
     * if yes, write it in the StackMapTable attribute.
     */
    private void endFrame() {
<span class="nc bnc" id="L1842" title="All 2 branches missed.">        if (previousFrame != null) { // do not write the first frame</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">            if (stackMap == null) {</span>
<span class="nc" id="L1844">                stackMap = new ByteVector();</span>
            }
<span class="nc" id="L1846">            writeFrame();</span>
<span class="nc" id="L1847">            ++frameCount;</span>
        }
<span class="nc" id="L1849">        previousFrame = frame;</span>
<span class="nc" id="L1850">        frame = null;</span>
<span class="nc" id="L1851">    }</span>

    /**
     * Compress and writes the current frame {@link #frame} in the StackMapTable
     * attribute.
     */
    private void writeFrame() {
<span class="nc" id="L1858">        int clocalsSize = frame[1];</span>
<span class="nc" id="L1859">        int cstackSize = frame[2];</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">        if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_6) {</span>
<span class="nc" id="L1861">            stackMap.putShort(frame[0]).putShort(clocalsSize);</span>
<span class="nc" id="L1862">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1863">            stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1864">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
<span class="nc" id="L1865">            return;</span>
        }
<span class="nc" id="L1867">        int localsSize = previousFrame[1];</span>
<span class="nc" id="L1868">        int type = FULL_FRAME;</span>
<span class="nc" id="L1869">        int k = 0;</span>
        int delta;
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (frameCount == 0) {</span>
<span class="nc" id="L1872">            delta = frame[0];</span>
        } else {
<span class="nc" id="L1874">            delta = frame[0] - previousFrame[0] - 1;</span>
        }
<span class="nc bnc" id="L1876" title="All 2 branches missed.">        if (cstackSize == 0) {</span>
<span class="nc" id="L1877">            k = clocalsSize - localsSize;</span>
<span class="nc bnc" id="L1878" title="All 4 branches missed.">            switch (k) {</span>
            case -3:
            case -2:
            case -1:
<span class="nc" id="L1882">                type = CHOP_FRAME;</span>
<span class="nc" id="L1883">                localsSize = clocalsSize;</span>
<span class="nc" id="L1884">                break;</span>
            case 0:
<span class="nc bnc" id="L1886" title="All 2 branches missed.">                type = delta &lt; 64 ? SAME_FRAME : SAME_FRAME_EXTENDED;</span>
<span class="nc" id="L1887">                break;</span>
            case 1:
            case 2:
            case 3:
<span class="nc" id="L1891">                type = APPEND_FRAME;</span>
<span class="nc" id="L1892">                break;</span>
            }
<span class="nc bnc" id="L1894" title="All 4 branches missed.">        } else if (clocalsSize == localsSize &amp;&amp; cstackSize == 1) {</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">            type = delta &lt; 63 ? SAME_LOCALS_1_STACK_ITEM_FRAME</span>
                    : SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
        }
<span class="nc bnc" id="L1898" title="All 2 branches missed.">        if (type != FULL_FRAME) {</span>
            // verify if locals are the same
<span class="nc" id="L1900">            int l = 3;</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">            for (int j = 0; j &lt; localsSize; j++) {</span>
<span class="nc bnc" id="L1902" title="All 2 branches missed.">                if (frame[l] != previousFrame[l]) {</span>
<span class="nc" id="L1903">                    type = FULL_FRAME;</span>
<span class="nc" id="L1904">                    break;</span>
                }
<span class="nc" id="L1906">                l++;</span>
            }
        }
<span class="nc bnc" id="L1909" title="All 7 branches missed.">        switch (type) {</span>
        case SAME_FRAME:
<span class="nc" id="L1911">            stackMap.putByte(delta);</span>
<span class="nc" id="L1912">            break;</span>
        case SAME_LOCALS_1_STACK_ITEM_FRAME:
<span class="nc" id="L1914">            stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME + delta);</span>
<span class="nc" id="L1915">            writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="nc" id="L1916">            break;</span>
        case SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
<span class="nc" id="L1918">            stackMap.putByte(SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED).putShort(</span>
                    delta);
<span class="nc" id="L1920">            writeFrameTypes(3 + clocalsSize, 4 + clocalsSize);</span>
<span class="nc" id="L1921">            break;</span>
        case SAME_FRAME_EXTENDED:
<span class="nc" id="L1923">            stackMap.putByte(SAME_FRAME_EXTENDED).putShort(delta);</span>
<span class="nc" id="L1924">            break;</span>
        case CHOP_FRAME:
<span class="nc" id="L1926">            stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="nc" id="L1927">            break;</span>
        case APPEND_FRAME:
<span class="nc" id="L1929">            stackMap.putByte(SAME_FRAME_EXTENDED + k).putShort(delta);</span>
<span class="nc" id="L1930">            writeFrameTypes(3 + localsSize, 3 + clocalsSize);</span>
<span class="nc" id="L1931">            break;</span>
        // case FULL_FRAME:
        default:
<span class="nc" id="L1934">            stackMap.putByte(FULL_FRAME).putShort(delta).putShort(clocalsSize);</span>
<span class="nc" id="L1935">            writeFrameTypes(3, 3 + clocalsSize);</span>
<span class="nc" id="L1936">            stackMap.putShort(cstackSize);</span>
<span class="nc" id="L1937">            writeFrameTypes(3 + clocalsSize, 3 + clocalsSize + cstackSize);</span>
        }
<span class="nc" id="L1939">    }</span>

    /**
     * Writes some types of the current frame {@link #frame} into the
     * StackMapTableAttribute. This method converts types from the format used
     * in {@link Label} to the format used in StackMapTable attributes. In
     * particular, it converts type table indexes to constant pool indexes.
     *
     * @param start
     *            index of the first type in {@link #frame} to write.
     * @param end
     *            index of last type in {@link #frame} to write (exclusive).
     */
    private void writeFrameTypes(final int start, final int end) {
<span class="nc bnc" id="L1953" title="All 2 branches missed.">        for (int i = start; i &lt; end; ++i) {</span>
<span class="nc" id="L1954">            int t = frame[i];</span>
<span class="nc" id="L1955">            int d = t &amp; Frame.DIM;</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">            if (d == 0) {</span>
<span class="nc" id="L1957">                int v = t &amp; Frame.BASE_VALUE;</span>
<span class="nc bnc" id="L1958" title="All 3 branches missed.">                switch (t &amp; Frame.BASE_KIND) {</span>
                case Frame.OBJECT:
<span class="nc" id="L1960">                    stackMap.putByte(7).putShort(</span>
<span class="nc" id="L1961">                            cw.newClass(cw.typeTable[v].strVal1));</span>
<span class="nc" id="L1962">                    break;</span>
                case Frame.UNINITIALIZED:
<span class="nc" id="L1964">                    stackMap.putByte(8).putShort(cw.typeTable[v].intVal);</span>
<span class="nc" id="L1965">                    break;</span>
                default:
<span class="nc" id="L1967">                    stackMap.putByte(v);</span>
                }
<span class="nc" id="L1969">            } else {</span>
<span class="nc" id="L1970">                StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1971">                d &gt;&gt;= 28;</span>
<span class="nc bnc" id="L1972" title="All 2 branches missed.">                while (d-- &gt; 0) {</span>
<span class="nc" id="L1973">                    sb.append('[');</span>
                }
<span class="nc bnc" id="L1975" title="All 2 branches missed.">                if ((t &amp; Frame.BASE_KIND) == Frame.OBJECT) {</span>
<span class="nc" id="L1976">                    sb.append('L');</span>
<span class="nc" id="L1977">                    sb.append(cw.typeTable[t &amp; Frame.BASE_VALUE].strVal1);</span>
<span class="nc" id="L1978">                    sb.append(';');</span>
                } else {
<span class="nc bnc" id="L1980" title="All 8 branches missed.">                    switch (t &amp; 0xF) {</span>
                    case 1:
<span class="nc" id="L1982">                        sb.append('I');</span>
<span class="nc" id="L1983">                        break;</span>
                    case 2:
<span class="nc" id="L1985">                        sb.append('F');</span>
<span class="nc" id="L1986">                        break;</span>
                    case 3:
<span class="nc" id="L1988">                        sb.append('D');</span>
<span class="nc" id="L1989">                        break;</span>
                    case 9:
<span class="nc" id="L1991">                        sb.append('Z');</span>
<span class="nc" id="L1992">                        break;</span>
                    case 10:
<span class="nc" id="L1994">                        sb.append('B');</span>
<span class="nc" id="L1995">                        break;</span>
                    case 11:
<span class="nc" id="L1997">                        sb.append('C');</span>
<span class="nc" id="L1998">                        break;</span>
                    case 12:
<span class="nc" id="L2000">                        sb.append('S');</span>
<span class="nc" id="L2001">                        break;</span>
                    default:
<span class="nc" id="L2003">                        sb.append('J');</span>
                    }
                }
<span class="nc" id="L2006">                stackMap.putByte(7).putShort(cw.newClass(sb.toString()));</span>
            }
        }
<span class="nc" id="L2009">    }</span>

    private void writeFrameType(final Object type) {
<span class="nc bnc" id="L2012" title="All 2 branches missed.">        if (type instanceof String) {</span>
<span class="nc" id="L2013">            stackMap.putByte(7).putShort(cw.newClass((String) type));</span>
<span class="nc bnc" id="L2014" title="All 2 branches missed.">        } else if (type instanceof Integer) {</span>
<span class="nc" id="L2015">            stackMap.putByte(((Integer) type).intValue());</span>
        } else {
<span class="nc" id="L2017">            stackMap.putByte(8).putShort(((Label) type).position);</span>
        }
<span class="nc" id="L2019">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: dump bytecode array
    // ------------------------------------------------------------------------

    /**
     * Returns the size of the bytecode of this method.
     *
     * @return the size of the bytecode of this method.
     */
    final int getSize() {
<span class="nc bnc" id="L2031" title="All 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L2032">            return 6 + classReaderLength;</span>
        }
<span class="nc" id="L2034">        int size = 8;</span>
<span class="nc bnc" id="L2035" title="All 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc bnc" id="L2036" title="All 2 branches missed.">            if (code.length &gt; 65536) {</span>
<span class="nc" id="L2037">                throw new RuntimeException(&quot;Method code too large!&quot;);</span>
            }
<span class="nc" id="L2039">            cw.newUTF8(&quot;Code&quot;);</span>
<span class="nc" id="L2040">            size += 18 + code.length + 8 * handlerCount;</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L2042">                cw.newUTF8(&quot;LocalVariableTable&quot;);</span>
<span class="nc" id="L2043">                size += 8 + localVar.length;</span>
            }
<span class="nc bnc" id="L2045" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2046">                cw.newUTF8(&quot;LocalVariableTypeTable&quot;);</span>
<span class="nc" id="L2047">                size += 8 + localVarType.length;</span>
            }
<span class="nc bnc" id="L2049" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L2050">                cw.newUTF8(&quot;LineNumberTable&quot;);</span>
<span class="nc" id="L2051">                size += 8 + lineNumber.length;</span>
            }
<span class="nc bnc" id="L2053" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">                cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;);</span>
<span class="nc" id="L2056">                size += 8 + stackMap.length;</span>
            }
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2059">                cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2060">                size += 8 + ctanns.getSize();</span>
            }
<span class="nc bnc" id="L2062" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2063">                cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2064">                size += 8 + ictanns.getSize();</span>
            }
<span class="nc bnc" id="L2066" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2067">                size += cattrs.getSize(cw, code.data, code.length, maxStack,</span>
                        maxLocals);
            }
        }
<span class="nc bnc" id="L2071" title="All 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="nc" id="L2072">            cw.newUTF8(&quot;Exceptions&quot;);</span>
<span class="nc" id="L2073">            size += 8 + 2 * exceptionCount;</span>
        }
<span class="nc bnc" id="L2075" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2076" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2078">                cw.newUTF8(&quot;Synthetic&quot;);</span>
<span class="nc" id="L2079">                size += 6;</span>
            }
        }
<span class="nc bnc" id="L2082" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2083">            cw.newUTF8(&quot;Deprecated&quot;);</span>
<span class="nc" id="L2084">            size += 6;</span>
        }
<span class="nc bnc" id="L2086" title="All 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2087">            cw.newUTF8(&quot;Signature&quot;);</span>
<span class="nc" id="L2088">            cw.newUTF8(signature);</span>
<span class="nc" id="L2089">            size += 8;</span>
        }
<span class="nc bnc" id="L2091" title="All 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2092">            cw.newUTF8(&quot;MethodParameters&quot;);</span>
<span class="nc" id="L2093">            size += 7 + methodParameters.length;</span>
        }
<span class="nc bnc" id="L2095" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2096">            cw.newUTF8(&quot;AnnotationDefault&quot;);</span>
<span class="nc" id="L2097">            size += 6 + annd.length;</span>
        }
<span class="nc bnc" id="L2099" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L2100">            cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;);</span>
<span class="nc" id="L2101">            size += 8 + anns.getSize();</span>
        }
<span class="nc bnc" id="L2103" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2104">            cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;);</span>
<span class="nc" id="L2105">            size += 8 + ianns.getSize();</span>
        }
<span class="nc bnc" id="L2107" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2108">            cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2109">            size += 8 + tanns.getSize();</span>
        }
<span class="nc bnc" id="L2111" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2112">            cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;);</span>
<span class="nc" id="L2113">            size += 8 + itanns.getSize();</span>
        }
<span class="nc bnc" id="L2115" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2116">            cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L2117">            size += 7 + 2 * (panns.length - synthetics);</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">            for (int i = panns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L2119" title="All 2 branches missed.">                size += panns[i] == null ? 0 : panns[i].getSize();</span>
            }
        }
<span class="nc bnc" id="L2122" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2123">            cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;);</span>
<span class="nc" id="L2124">            size += 7 + 2 * (ipanns.length - synthetics);</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">            for (int i = ipanns.length - 1; i &gt;= synthetics; --i) {</span>
<span class="nc bnc" id="L2126" title="All 2 branches missed.">                size += ipanns[i] == null ? 0 : ipanns[i].getSize();</span>
            }
        }
<span class="nc bnc" id="L2129" title="All 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2130">            size += attrs.getSize(cw, null, 0, -1, -1);</span>
        }
<span class="nc" id="L2132">        return size;</span>
    }

    /**
     * Puts the bytecode of this method in the given byte vector.
     *
     * @param out
     *            the byte vector into which the bytecode of this method must be
     *            copied.
     */
    final void put(final ByteVector out) {
<span class="nc" id="L2143">        final int FACTOR = ClassWriter.TO_ACC_SYNTHETIC;</span>
<span class="nc" id="L2144">        int mask = ACC_CONSTRUCTOR | Opcodes.ACC_DEPRECATED</span>
                | ClassWriter.ACC_SYNTHETIC_ATTRIBUTE
                | ((access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) / FACTOR);
<span class="nc" id="L2147">        out.putShort(access &amp; ~mask).putShort(name).putShort(desc);</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">        if (classReaderOffset != 0) {</span>
<span class="nc" id="L2149">            out.putByteArray(cw.cr.b, classReaderOffset, classReaderLength);</span>
<span class="nc" id="L2150">            return;</span>
        }
<span class="nc" id="L2152">        int attributeCount = 0;</span>
<span class="nc bnc" id="L2153" title="All 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc" id="L2154">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2156" title="All 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="nc" id="L2157">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2159" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2160" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2162">                ++attributeCount;</span>
            }
        }
<span class="nc bnc" id="L2165" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2166">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2168" title="All 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2169">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2171" title="All 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2172">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2174" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2175">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2177" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L2178">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2180" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2181">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2183" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2184">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2186" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2187">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2189" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2190">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2192" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2193">            ++attributeCount;</span>
        }
<span class="nc bnc" id="L2195" title="All 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2196">            attributeCount += attrs.getCount();</span>
        }
<span class="nc" id="L2198">        out.putShort(attributeCount);</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">        if (code.length &gt; 0) {</span>
<span class="nc" id="L2200">            int size = 12 + code.length + 8 * handlerCount;</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L2202">                size += 8 + localVar.length;</span>
            }
<span class="nc bnc" id="L2204" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2205">                size += 8 + localVarType.length;</span>
            }
<span class="nc bnc" id="L2207" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L2208">                size += 8 + lineNumber.length;</span>
            }
<span class="nc bnc" id="L2210" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L2211">                size += 8 + stackMap.length;</span>
            }
<span class="nc bnc" id="L2213" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2214">                size += 8 + ctanns.getSize();</span>
            }
<span class="nc bnc" id="L2216" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2217">                size += 8 + ictanns.getSize();</span>
            }
<span class="nc bnc" id="L2219" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2220">                size += cattrs.getSize(cw, code.data, code.length, maxStack,</span>
                        maxLocals);
            }
<span class="nc" id="L2223">            out.putShort(cw.newUTF8(&quot;Code&quot;)).putInt(size);</span>
<span class="nc" id="L2224">            out.putShort(maxStack).putShort(maxLocals);</span>
<span class="nc" id="L2225">            out.putInt(code.length).putByteArray(code.data, 0, code.length);</span>
<span class="nc" id="L2226">            out.putShort(handlerCount);</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">            if (handlerCount &gt; 0) {</span>
<span class="nc" id="L2228">                Handler h = firstHandler;</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">                while (h != null) {</span>
<span class="nc" id="L2230">                    out.putShort(h.start.position).putShort(h.end.position)</span>
<span class="nc" id="L2231">                            .putShort(h.handler.position).putShort(h.type);</span>
<span class="nc" id="L2232">                    h = h.next;</span>
                }
            }
<span class="nc" id="L2235">            attributeCount = 0;</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L2237">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2239" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2240">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2242" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L2243">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2245" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc" id="L2246">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2248" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2249">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2251" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2252">                ++attributeCount;</span>
            }
<span class="nc bnc" id="L2254" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2255">                attributeCount += cattrs.getCount();</span>
            }
<span class="nc" id="L2257">            out.putShort(attributeCount);</span>
<span class="nc bnc" id="L2258" title="All 2 branches missed.">            if (localVar != null) {</span>
<span class="nc" id="L2259">                out.putShort(cw.newUTF8(&quot;LocalVariableTable&quot;));</span>
<span class="nc" id="L2260">                out.putInt(localVar.length + 2).putShort(localVarCount);</span>
<span class="nc" id="L2261">                out.putByteArray(localVar.data, 0, localVar.length);</span>
            }
<span class="nc bnc" id="L2263" title="All 2 branches missed.">            if (localVarType != null) {</span>
<span class="nc" id="L2264">                out.putShort(cw.newUTF8(&quot;LocalVariableTypeTable&quot;));</span>
<span class="nc" id="L2265">                out.putInt(localVarType.length + 2).putShort(localVarTypeCount);</span>
<span class="nc" id="L2266">                out.putByteArray(localVarType.data, 0, localVarType.length);</span>
            }
<span class="nc bnc" id="L2268" title="All 2 branches missed.">            if (lineNumber != null) {</span>
<span class="nc" id="L2269">                out.putShort(cw.newUTF8(&quot;LineNumberTable&quot;));</span>
<span class="nc" id="L2270">                out.putInt(lineNumber.length + 2).putShort(lineNumberCount);</span>
<span class="nc" id="L2271">                out.putByteArray(lineNumber.data, 0, lineNumber.length);</span>
            }
<span class="nc bnc" id="L2273" title="All 2 branches missed.">            if (stackMap != null) {</span>
<span class="nc bnc" id="L2274" title="All 2 branches missed.">                boolean zip = (cw.version &amp; 0xFFFF) &gt;= Opcodes.V1_6;</span>
<span class="nc bnc" id="L2275" title="All 2 branches missed.">                out.putShort(cw.newUTF8(zip ? &quot;StackMapTable&quot; : &quot;StackMap&quot;));</span>
<span class="nc" id="L2276">                out.putInt(stackMap.length + 2).putShort(frameCount);</span>
<span class="nc" id="L2277">                out.putByteArray(stackMap.data, 0, stackMap.length);</span>
            }
<span class="nc bnc" id="L2279" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ctanns != null) {</span>
<span class="nc" id="L2280">                out.putShort(cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2281">                ctanns.put(out);</span>
            }
<span class="nc bnc" id="L2283" title="All 2 branches missed.">            if (ClassReader.ANNOTATIONS &amp;&amp; ictanns != null) {</span>
<span class="nc" id="L2284">                out.putShort(cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2285">                ictanns.put(out);</span>
            }
<span class="nc bnc" id="L2287" title="All 2 branches missed.">            if (cattrs != null) {</span>
<span class="nc" id="L2288">                cattrs.put(cw, code.data, code.length, maxLocals, maxStack, out);</span>
            }
        }
<span class="nc bnc" id="L2291" title="All 2 branches missed.">        if (exceptionCount &gt; 0) {</span>
<span class="nc" id="L2292">            out.putShort(cw.newUTF8(&quot;Exceptions&quot;)).putInt(</span>
                    2 * exceptionCount + 2);
<span class="nc" id="L2294">            out.putShort(exceptionCount);</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">            for (int i = 0; i &lt; exceptionCount; ++i) {</span>
<span class="nc" id="L2296">                out.putShort(exceptions[i]);</span>
            }
        }
<span class="nc bnc" id="L2299" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_SYNTHETIC) != 0) {</span>
<span class="nc bnc" id="L2300" title="All 4 branches missed.">            if ((cw.version &amp; 0xFFFF) &lt; Opcodes.V1_5</span>
                    || (access &amp; ClassWriter.ACC_SYNTHETIC_ATTRIBUTE) != 0) {
<span class="nc" id="L2302">                out.putShort(cw.newUTF8(&quot;Synthetic&quot;)).putInt(0);</span>
            }
        }
<span class="nc bnc" id="L2305" title="All 2 branches missed.">        if ((access &amp; Opcodes.ACC_DEPRECATED) != 0) {</span>
<span class="nc" id="L2306">            out.putShort(cw.newUTF8(&quot;Deprecated&quot;)).putInt(0);</span>
        }
<span class="nc bnc" id="L2308" title="All 2 branches missed.">        if (ClassReader.SIGNATURES &amp;&amp; signature != null) {</span>
<span class="nc" id="L2309">            out.putShort(cw.newUTF8(&quot;Signature&quot;)).putInt(2)</span>
<span class="nc" id="L2310">                    .putShort(cw.newUTF8(signature));</span>
        }
<span class="nc bnc" id="L2312" title="All 2 branches missed.">        if (methodParameters != null) {</span>
<span class="nc" id="L2313">            out.putShort(cw.newUTF8(&quot;MethodParameters&quot;));</span>
<span class="nc" id="L2314">            out.putInt(methodParameters.length + 1).putByte(</span>
                    methodParametersCount);
<span class="nc" id="L2316">            out.putByteArray(methodParameters.data, 0, methodParameters.length);</span>
        }
<span class="nc bnc" id="L2318" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; annd != null) {</span>
<span class="nc" id="L2319">            out.putShort(cw.newUTF8(&quot;AnnotationDefault&quot;));</span>
<span class="nc" id="L2320">            out.putInt(annd.length);</span>
<span class="nc" id="L2321">            out.putByteArray(annd.data, 0, annd.length);</span>
        }
<span class="nc bnc" id="L2323" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; anns != null) {</span>
<span class="nc" id="L2324">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleAnnotations&quot;));</span>
<span class="nc" id="L2325">            anns.put(out);</span>
        }
<span class="nc bnc" id="L2327" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ianns != null) {</span>
<span class="nc" id="L2328">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleAnnotations&quot;));</span>
<span class="nc" id="L2329">            ianns.put(out);</span>
        }
<span class="nc bnc" id="L2331" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; tanns != null) {</span>
<span class="nc" id="L2332">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2333">            tanns.put(out);</span>
        }
<span class="nc bnc" id="L2335" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; itanns != null) {</span>
<span class="nc" id="L2336">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleTypeAnnotations&quot;));</span>
<span class="nc" id="L2337">            itanns.put(out);</span>
        }
<span class="nc bnc" id="L2339" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; panns != null) {</span>
<span class="nc" id="L2340">            out.putShort(cw.newUTF8(&quot;RuntimeVisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2341">            AnnotationWriter.put(panns, synthetics, out);</span>
        }
<span class="nc bnc" id="L2343" title="All 2 branches missed.">        if (ClassReader.ANNOTATIONS &amp;&amp; ipanns != null) {</span>
<span class="nc" id="L2344">            out.putShort(cw.newUTF8(&quot;RuntimeInvisibleParameterAnnotations&quot;));</span>
<span class="nc" id="L2345">            AnnotationWriter.put(ipanns, synthetics, out);</span>
        }
<span class="nc bnc" id="L2347" title="All 2 branches missed.">        if (attrs != null) {</span>
<span class="nc" id="L2348">            attrs.put(cw, null, 0, -1, -1, out);</span>
        }
<span class="nc" id="L2350">    }</span>

    // ------------------------------------------------------------------------
    // Utility methods: instruction resizing (used to handle GOTO_W and JSR_W)
    // ------------------------------------------------------------------------

    /**
     * Resizes and replaces the temporary instructions inserted by
     * {@link Label#resolve} for wide forward jumps, while keeping jump offsets
     * and instruction addresses consistent. This may require to resize other
     * existing instructions, or even to introduce new instructions: for
     * example, increasing the size of an instruction by 2 at the middle of a
     * method can increases the offset of an IFEQ instruction from 32766 to
     * 32768, in which case IFEQ 32766 must be replaced with IFNEQ 8 GOTO_W
     * 32765. This, in turn, may require to increase the size of another jump
     * instruction, and so on... All these operations are handled automatically
     * by this method.
     * &lt;p&gt;
     * &lt;i&gt;This method must be called after all the method that is being built
     * has been visited&lt;/i&gt;. In particular, the {@link Label Label} objects used
     * to construct the method are no longer valid after this method has been
     * called.
     */
    private void resizeInstructions() {
<span class="nc" id="L2374">        byte[] b = code.data; // bytecode of the method</span>
        int u, v, label; // indexes in b
        int i, j; // loop indexes
        /*
         * 1st step: As explained above, resizing an instruction may require to
         * resize another one, which may require to resize yet another one, and
         * so on. The first step of the algorithm consists in finding all the
         * instructions that need to be resized, without modifying the code.
         * This is done by the following &quot;fix point&quot; algorithm:
         *
         * Parse the code to find the jump instructions whose offset will need
         * more than 2 bytes to be stored (the future offset is computed from
         * the current offset and from the number of bytes that will be inserted
         * or removed between the source and target instructions). For each such
         * instruction, adds an entry in (a copy of) the indexes and sizes
         * arrays (if this has not already been done in a previous iteration!).
         *
         * If at least one entry has been added during the previous step, go
         * back to the beginning, otherwise stop.
         *
         * In fact the real algorithm is complicated by the fact that the size
         * of TABLESWITCH and LOOKUPSWITCH instructions depends on their
         * position in the bytecode (because of padding). In order to ensure the
         * convergence of the algorithm, the number of bytes to be added or
         * removed from these instructions is over estimated during the previous
         * loop, and computed exactly only after the loop is finished (this
         * requires another pass to parse the bytecode of the method).
         */
<span class="nc" id="L2402">        int[] allIndexes = new int[0]; // copy of indexes</span>
<span class="nc" id="L2403">        int[] allSizes = new int[0]; // copy of sizes</span>
        boolean[] resize; // instructions to be resized
        int newOffset; // future offset of a jump instruction

<span class="nc" id="L2407">        resize = new boolean[code.length];</span>

        // 3 = loop again, 2 = loop ended, 1 = last pass, 0 = done
<span class="nc" id="L2410">        int state = 3;</span>
        do {
<span class="nc bnc" id="L2412" title="All 2 branches missed.">            if (state == 3) {</span>
<span class="nc" id="L2413">                state = 2;</span>
            }
<span class="nc" id="L2415">            u = 0;</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">            while (u &lt; b.length) {</span>
<span class="nc" id="L2417">                int opcode = b[u] &amp; 0xFF; // opcode of current instruction</span>
<span class="nc" id="L2418">                int insert = 0; // bytes to be added after this instruction</span>

<span class="nc bnc" id="L2420" title="All 10 branches missed.">                switch (ClassWriter.TYPE[opcode]) {</span>
                case ClassWriter.NOARG_INSN:
                case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2423">                    u += 1;</span>
<span class="nc" id="L2424">                    break;</span>
                case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2426" title="All 2 branches missed.">                    if (opcode &gt; 201) {</span>
                        // converts temporary opcodes 202 to 217, 218 and
                        // 219 to IFEQ ... JSR (inclusive), IFNULL and
                        // IFNONNULL
<span class="nc bnc" id="L2430" title="All 2 branches missed.">                        opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2431">                        label = u + readUnsignedShort(b, u + 1);</span>
                    } else {
<span class="nc" id="L2433">                        label = u + readShort(b, u + 1);</span>
                    }
<span class="nc" id="L2435">                    newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2436" title="All 4 branches missed.">                    if (newOffset &lt; Short.MIN_VALUE</span>
                            || newOffset &gt; Short.MAX_VALUE) {
<span class="nc bnc" id="L2438" title="All 2 branches missed.">                        if (!resize[u]) {</span>
<span class="nc bnc" id="L2439" title="All 4 branches missed.">                            if (opcode == Opcodes.GOTO || opcode == Opcodes.JSR) {</span>
                                // two additional bytes will be required to
                                // replace this GOTO or JSR instruction with
                                // a GOTO_W or a JSR_W
<span class="nc" id="L2443">                                insert = 2;</span>
                            } else {
                                // five additional bytes will be required to
                                // replace this IFxxx &lt;l&gt; instruction with
                                // IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx
                                // is the &quot;opposite&quot; opcode of IFxxx (i.e.,
                                // IFNE for IFEQ) and where &lt;l'&gt; designates
                                // the instruction just after the GOTO_W.
<span class="nc" id="L2451">                                insert = 5;</span>
                            }
<span class="nc" id="L2453">                            resize[u] = true;</span>
                        }
                    }
<span class="nc" id="L2456">                    u += 3;</span>
<span class="nc" id="L2457">                    break;</span>
                case ClassWriter.LABELW_INSN:
<span class="nc" id="L2459">                    u += 5;</span>
<span class="nc" id="L2460">                    break;</span>
                case ClassWriter.TABL_INSN:
<span class="nc bnc" id="L2462" title="All 2 branches missed.">                    if (state == 1) {</span>
                        // true number of bytes to be added (or removed)
                        // from this instruction = (future number of padding
                        // bytes - current number of padding byte) -
                        // previously over estimated variation =
                        // = ((3 - newOffset%4) - (3 - u%4)) - u%4
                        // = (-newOffset%4 + u%4) - u%4
                        // = -(newOffset &amp; 3)
<span class="nc" id="L2470">                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2471">                        insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">                    } else if (!resize[u]) {</span>
                        // over estimation of the number of bytes to be
                        // added to this instruction = 3 - current number
                        // of padding bytes = 3 - (3 - u%4) = u%4 = u &amp; 3
<span class="nc" id="L2476">                        insert = u &amp; 3;</span>
<span class="nc" id="L2477">                        resize[u] = true;</span>
                    }
                    // skips instruction
<span class="nc" id="L2480">                    u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2481">                    u += 4 * (readInt(b, u + 8) - readInt(b, u + 4) + 1) + 12;</span>
<span class="nc" id="L2482">                    break;</span>
                case ClassWriter.LOOK_INSN:
<span class="nc bnc" id="L2484" title="All 2 branches missed.">                    if (state == 1) {</span>
                        // like TABL_INSN
<span class="nc" id="L2486">                        newOffset = getNewOffset(allIndexes, allSizes, 0, u);</span>
<span class="nc" id="L2487">                        insert = -(newOffset &amp; 3);</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">                    } else if (!resize[u]) {</span>
                        // like TABL_INSN
<span class="nc" id="L2490">                        insert = u &amp; 3;</span>
<span class="nc" id="L2491">                        resize[u] = true;</span>
                    }
                    // skips instruction
<span class="nc" id="L2494">                    u = u + 4 - (u &amp; 3);</span>
<span class="nc" id="L2495">                    u += 8 * readInt(b, u + 4) + 8;</span>
<span class="nc" id="L2496">                    break;</span>
                case ClassWriter.WIDE_INSN:
<span class="nc" id="L2498">                    opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2499" title="All 2 branches missed.">                    if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2500">                        u += 6;</span>
                    } else {
<span class="nc" id="L2502">                        u += 4;</span>
                    }
<span class="nc" id="L2504">                    break;</span>
                case ClassWriter.VAR_INSN:
                case ClassWriter.SBYTE_INSN:
                case ClassWriter.LDC_INSN:
<span class="nc" id="L2508">                    u += 2;</span>
<span class="nc" id="L2509">                    break;</span>
                case ClassWriter.SHORT_INSN:
                case ClassWriter.LDCW_INSN:
                case ClassWriter.FIELDORMETH_INSN:
                case ClassWriter.TYPE_INSN:
                case ClassWriter.IINC_INSN:
<span class="nc" id="L2515">                    u += 3;</span>
<span class="nc" id="L2516">                    break;</span>
                case ClassWriter.ITFMETH_INSN:
                case ClassWriter.INDYMETH_INSN:
<span class="nc" id="L2519">                    u += 5;</span>
<span class="nc" id="L2520">                    break;</span>
                // case ClassWriter.MANA_INSN:
                default:
<span class="nc" id="L2523">                    u += 4;</span>
                    break;
                }
<span class="nc bnc" id="L2526" title="All 2 branches missed.">                if (insert != 0) {</span>
                    // adds a new (u, insert) entry in the allIndexes and
                    // allSizes arrays
<span class="nc" id="L2529">                    int[] newIndexes = new int[allIndexes.length + 1];</span>
<span class="nc" id="L2530">                    int[] newSizes = new int[allSizes.length + 1];</span>
<span class="nc" id="L2531">                    System.arraycopy(allIndexes, 0, newIndexes, 0,</span>
                            allIndexes.length);
<span class="nc" id="L2533">                    System.arraycopy(allSizes, 0, newSizes, 0, allSizes.length);</span>
<span class="nc" id="L2534">                    newIndexes[allIndexes.length] = u;</span>
<span class="nc" id="L2535">                    newSizes[allSizes.length] = insert;</span>
<span class="nc" id="L2536">                    allIndexes = newIndexes;</span>
<span class="nc" id="L2537">                    allSizes = newSizes;</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">                    if (insert &gt; 0) {</span>
<span class="nc" id="L2539">                        state = 3;</span>
                    }
                }
<span class="nc" id="L2542">            }</span>
<span class="nc bnc" id="L2543" title="All 2 branches missed.">            if (state &lt; 3) {</span>
<span class="nc" id="L2544">                --state;</span>
            }
<span class="nc bnc" id="L2546" title="All 2 branches missed.">        } while (state != 0);</span>

        // 2nd step:
        // copies the bytecode of the method into a new bytevector, updates the
        // offsets, and inserts (or removes) bytes as requested.

<span class="nc" id="L2552">        ByteVector newCode = new ByteVector(code.length);</span>

<span class="nc" id="L2554">        u = 0;</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">        while (u &lt; code.length) {</span>
<span class="nc" id="L2556">            int opcode = b[u] &amp; 0xFF;</span>
<span class="nc bnc" id="L2557" title="All 10 branches missed.">            switch (ClassWriter.TYPE[opcode]) {</span>
            case ClassWriter.NOARG_INSN:
            case ClassWriter.IMPLVAR_INSN:
<span class="nc" id="L2560">                newCode.putByte(opcode);</span>
<span class="nc" id="L2561">                u += 1;</span>
<span class="nc" id="L2562">                break;</span>
            case ClassWriter.LABEL_INSN:
<span class="nc bnc" id="L2564" title="All 2 branches missed.">                if (opcode &gt; 201) {</span>
                    // changes temporary opcodes 202 to 217 (inclusive), 218
                    // and 219 to IFEQ ... JSR (inclusive), IFNULL and
                    // IFNONNULL
<span class="nc bnc" id="L2568" title="All 2 branches missed.">                    opcode = opcode &lt; 218 ? opcode - 49 : opcode - 20;</span>
<span class="nc" id="L2569">                    label = u + readUnsignedShort(b, u + 1);</span>
                } else {
<span class="nc" id="L2571">                    label = u + readShort(b, u + 1);</span>
                }
<span class="nc" id="L2573">                newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc bnc" id="L2574" title="All 2 branches missed.">                if (resize[u]) {</span>
                    // replaces GOTO with GOTO_W, JSR with JSR_W and IFxxx
                    // &lt;l&gt; with IFNOTxxx &lt;l'&gt; GOTO_W &lt;l&gt;, where IFNOTxxx is
                    // the &quot;opposite&quot; opcode of IFxxx (i.e., IFNE for IFEQ)
                    // and where &lt;l'&gt; designates the instruction just after
                    // the GOTO_W.
<span class="nc bnc" id="L2580" title="All 2 branches missed.">                    if (opcode == Opcodes.GOTO) {</span>
<span class="nc" id="L2581">                        newCode.putByte(200); // GOTO_W</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">                    } else if (opcode == Opcodes.JSR) {</span>
<span class="nc" id="L2583">                        newCode.putByte(201); // JSR_W</span>
                    } else {
<span class="nc bnc" id="L2585" title="All 2 branches missed.">                        newCode.putByte(opcode &lt;= 166 ? ((opcode + 1) ^ 1) - 1</span>
                                : opcode ^ 1);
<span class="nc" id="L2587">                        newCode.putShort(8); // jump offset</span>
<span class="nc" id="L2588">                        newCode.putByte(200); // GOTO_W</span>
                        // newOffset now computed from start of GOTO_W
<span class="nc" id="L2590">                        newOffset -= 3;</span>
                    }
<span class="nc" id="L2592">                    newCode.putInt(newOffset);</span>
                } else {
<span class="nc" id="L2594">                    newCode.putByte(opcode);</span>
<span class="nc" id="L2595">                    newCode.putShort(newOffset);</span>
                }
<span class="nc" id="L2597">                u += 3;</span>
<span class="nc" id="L2598">                break;</span>
            case ClassWriter.LABELW_INSN:
<span class="nc" id="L2600">                label = u + readInt(b, u + 1);</span>
<span class="nc" id="L2601">                newOffset = getNewOffset(allIndexes, allSizes, u, label);</span>
<span class="nc" id="L2602">                newCode.putByte(opcode);</span>
<span class="nc" id="L2603">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2604">                u += 5;</span>
<span class="nc" id="L2605">                break;</span>
            case ClassWriter.TABL_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L2608">                v = u;</span>
<span class="nc" id="L2609">                u = u + 4 - (v &amp; 3);</span>
                // reads and copies instruction
<span class="nc" id="L2611">                newCode.putByte(Opcodes.TABLESWITCH);</span>
<span class="nc" id="L2612">                newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2613">                label = v + readInt(b, u);</span>
<span class="nc" id="L2614">                u += 4;</span>
<span class="nc" id="L2615">                newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2616">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2617">                j = readInt(b, u);</span>
<span class="nc" id="L2618">                u += 4;</span>
<span class="nc" id="L2619">                newCode.putInt(j);</span>
<span class="nc" id="L2620">                j = readInt(b, u) - j + 1;</span>
<span class="nc" id="L2621">                u += 4;</span>
<span class="nc" id="L2622">                newCode.putInt(readInt(b, u - 4));</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">                for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2624">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2625">                    u += 4;</span>
<span class="nc" id="L2626">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2627">                    newCode.putInt(newOffset);</span>
                }
                break;
            case ClassWriter.LOOK_INSN:
                // skips 0 to 3 padding bytes
<span class="nc" id="L2632">                v = u;</span>
<span class="nc" id="L2633">                u = u + 4 - (v &amp; 3);</span>
                // reads and copies instruction
<span class="nc" id="L2635">                newCode.putByte(Opcodes.LOOKUPSWITCH);</span>
<span class="nc" id="L2636">                newCode.putByteArray(null, 0, (4 - newCode.length % 4) % 4);</span>
<span class="nc" id="L2637">                label = v + readInt(b, u);</span>
<span class="nc" id="L2638">                u += 4;</span>
<span class="nc" id="L2639">                newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2640">                newCode.putInt(newOffset);</span>
<span class="nc" id="L2641">                j = readInt(b, u);</span>
<span class="nc" id="L2642">                u += 4;</span>
<span class="nc" id="L2643">                newCode.putInt(j);</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">                for (; j &gt; 0; --j) {</span>
<span class="nc" id="L2645">                    newCode.putInt(readInt(b, u));</span>
<span class="nc" id="L2646">                    u += 4;</span>
<span class="nc" id="L2647">                    label = v + readInt(b, u);</span>
<span class="nc" id="L2648">                    u += 4;</span>
<span class="nc" id="L2649">                    newOffset = getNewOffset(allIndexes, allSizes, v, label);</span>
<span class="nc" id="L2650">                    newCode.putInt(newOffset);</span>
                }
                break;
            case ClassWriter.WIDE_INSN:
<span class="nc" id="L2654">                opcode = b[u + 1] &amp; 0xFF;</span>
<span class="nc bnc" id="L2655" title="All 2 branches missed.">                if (opcode == Opcodes.IINC) {</span>
<span class="nc" id="L2656">                    newCode.putByteArray(b, u, 6);</span>
<span class="nc" id="L2657">                    u += 6;</span>
                } else {
<span class="nc" id="L2659">                    newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2660">                    u += 4;</span>
                }
<span class="nc" id="L2662">                break;</span>
            case ClassWriter.VAR_INSN:
            case ClassWriter.SBYTE_INSN:
            case ClassWriter.LDC_INSN:
<span class="nc" id="L2666">                newCode.putByteArray(b, u, 2);</span>
<span class="nc" id="L2667">                u += 2;</span>
<span class="nc" id="L2668">                break;</span>
            case ClassWriter.SHORT_INSN:
            case ClassWriter.LDCW_INSN:
            case ClassWriter.FIELDORMETH_INSN:
            case ClassWriter.TYPE_INSN:
            case ClassWriter.IINC_INSN:
<span class="nc" id="L2674">                newCode.putByteArray(b, u, 3);</span>
<span class="nc" id="L2675">                u += 3;</span>
<span class="nc" id="L2676">                break;</span>
            case ClassWriter.ITFMETH_INSN:
            case ClassWriter.INDYMETH_INSN:
<span class="nc" id="L2679">                newCode.putByteArray(b, u, 5);</span>
<span class="nc" id="L2680">                u += 5;</span>
<span class="nc" id="L2681">                break;</span>
            // case MANA_INSN:
            default:
<span class="nc" id="L2684">                newCode.putByteArray(b, u, 4);</span>
<span class="nc" id="L2685">                u += 4;</span>
                break;
            }
<span class="nc" id="L2688">        }</span>

        // updates the stack map frame labels
<span class="nc bnc" id="L2691" title="All 2 branches missed.">        if (compute == FRAMES) {</span>
<span class="nc" id="L2692">            Label l = labels;</span>
<span class="nc bnc" id="L2693" title="All 2 branches missed.">            while (l != null) {</span>
                /*
                 * Detects the labels that are just after an IF instruction that
                 * has been resized with the IFNOT GOTO_W pattern. These labels
                 * are now the target of a jump instruction (the IFNOT
                 * instruction). Note that we need the original label position
                 * here. getNewOffset must therefore never have been called for
                 * this label.
                 */
<span class="nc" id="L2702">                u = l.position - 3;</span>
<span class="nc bnc" id="L2703" title="All 4 branches missed.">                if (u &gt;= 0 &amp;&amp; resize[u]) {</span>
<span class="nc" id="L2704">                    l.status |= Label.TARGET;</span>
                }
<span class="nc" id="L2706">                getNewOffset(allIndexes, allSizes, l);</span>
<span class="nc" id="L2707">                l = l.successor;</span>
            }
            // Update the offsets in the uninitialized types
<span class="nc bnc" id="L2710" title="All 2 branches missed.">            for (i = 0; i &lt; cw.typeTable.length; ++i) {</span>
<span class="nc" id="L2711">                Item item = cw.typeTable[i];</span>
<span class="nc bnc" id="L2712" title="All 4 branches missed.">                if (item != null &amp;&amp; item.type == ClassWriter.TYPE_UNINIT) {</span>
<span class="nc" id="L2713">                    item.intVal = getNewOffset(allIndexes, allSizes, 0,</span>
                            item.intVal);
                }
            }
            // The stack map frames are not serialized yet, so we don't need
            // to update them. They will be serialized in visitMaxs.
<span class="nc bnc" id="L2719" title="All 2 branches missed.">        } else if (frameCount &gt; 0) {</span>
            /*
             * Resizing an existing stack map frame table is really hard. Not
             * only the table must be parsed to update the offets, but new
             * frames may be needed for jump instructions that were inserted by
             * this method. And updating the offsets or inserting frames can
             * change the format of the following frames, in case of packed
             * frames. In practice the whole table must be recomputed. For this
             * the frames are marked as potentially invalid. This will cause the
             * whole class to be reread and rewritten with the COMPUTE_FRAMES
             * option (see the ClassWriter.toByteArray method). This is not very
             * efficient but is much easier and requires much less code than any
             * other method I can think of.
             */
<span class="nc" id="L2733">            cw.invalidFrames = true;</span>
        }
        // updates the exception handler block labels
<span class="nc" id="L2736">        Handler h = firstHandler;</span>
<span class="nc bnc" id="L2737" title="All 2 branches missed.">        while (h != null) {</span>
<span class="nc" id="L2738">            getNewOffset(allIndexes, allSizes, h.start);</span>
<span class="nc" id="L2739">            getNewOffset(allIndexes, allSizes, h.end);</span>
<span class="nc" id="L2740">            getNewOffset(allIndexes, allSizes, h.handler);</span>
<span class="nc" id="L2741">            h = h.next;</span>
        }
        // updates the instructions addresses in the
        // local var and line number tables
<span class="nc bnc" id="L2745" title="All 2 branches missed.">        for (i = 0; i &lt; 2; ++i) {</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">            ByteVector bv = i == 0 ? localVar : localVarType;</span>
<span class="nc bnc" id="L2747" title="All 2 branches missed.">            if (bv != null) {</span>
<span class="nc" id="L2748">                b = bv.data;</span>
<span class="nc" id="L2749">                u = 0;</span>
<span class="nc bnc" id="L2750" title="All 2 branches missed.">                while (u &lt; bv.length) {</span>
<span class="nc" id="L2751">                    label = readUnsignedShort(b, u);</span>
<span class="nc" id="L2752">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label);</span>
<span class="nc" id="L2753">                    writeShort(b, u, newOffset);</span>
<span class="nc" id="L2754">                    label += readUnsignedShort(b, u + 2);</span>
<span class="nc" id="L2755">                    newOffset = getNewOffset(allIndexes, allSizes, 0, label)</span>
                            - newOffset;
<span class="nc" id="L2757">                    writeShort(b, u + 2, newOffset);</span>
<span class="nc" id="L2758">                    u += 10;</span>
                }
            }
        }
<span class="nc bnc" id="L2762" title="All 2 branches missed.">        if (lineNumber != null) {</span>
<span class="nc" id="L2763">            b = lineNumber.data;</span>
<span class="nc" id="L2764">            u = 0;</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">            while (u &lt; lineNumber.length) {</span>
<span class="nc" id="L2766">                writeShort(</span>
                        b,
                        u,
<span class="nc" id="L2769">                        getNewOffset(allIndexes, allSizes, 0,</span>
<span class="nc" id="L2770">                                readUnsignedShort(b, u)));</span>
<span class="nc" id="L2771">                u += 4;</span>
            }
        }
        // updates the labels of the other attributes
<span class="nc" id="L2775">        Attribute attr = cattrs;</span>
<span class="nc bnc" id="L2776" title="All 2 branches missed.">        while (attr != null) {</span>
<span class="nc" id="L2777">            Label[] labels = attr.getLabels();</span>
<span class="nc bnc" id="L2778" title="All 2 branches missed.">            if (labels != null) {</span>
<span class="nc bnc" id="L2779" title="All 2 branches missed.">                for (i = labels.length - 1; i &gt;= 0; --i) {</span>
<span class="nc" id="L2780">                    getNewOffset(allIndexes, allSizes, labels[i]);</span>
                }
            }
<span class="nc" id="L2783">            attr = attr.next;</span>
<span class="nc" id="L2784">        }</span>

        // replaces old bytecodes with new ones
<span class="nc" id="L2787">        code = newCode;</span>
<span class="nc" id="L2788">    }</span>

    /**
     * Reads an unsigned short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static int readUnsignedShort(final byte[] b, final int index) {
<span class="nc" id="L2800">        return ((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF);</span>
    }

    /**
     * Reads a signed short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static short readShort(final byte[] b, final int index) {
<span class="nc" id="L2813">        return (short) (((b[index] &amp; 0xFF) &lt;&lt; 8) | (b[index + 1] &amp; 0xFF));</span>
    }

    /**
     * Reads a signed int value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            the start index of the value to be read.
     * @return the read value.
     */
    static int readInt(final byte[] b, final int index) {
<span class="nc" id="L2826">        return ((b[index] &amp; 0xFF) &lt;&lt; 24) | ((b[index + 1] &amp; 0xFF) &lt;&lt; 16)</span>
                | ((b[index + 2] &amp; 0xFF) &lt;&lt; 8) | (b[index + 3] &amp; 0xFF);
    }

    /**
     * Writes a short value in the given byte array.
     *
     * @param b
     *            a byte array.
     * @param index
     *            where the first byte of the short value must be written.
     * @param s
     *            the value to be written in the given byte array.
     */
    static void writeShort(final byte[] b, final int index, final int s) {
<span class="nc" id="L2841">        b[index] = (byte) (s &gt;&gt;&gt; 8);</span>
<span class="nc" id="L2842">        b[index + 1] = (byte) s;</span>
<span class="nc" id="L2843">    }</span>

    /**
     * Computes the future value of a bytecode offset.
     * &lt;p&gt;
     * Note: it is possible to have several entries for the same instruction in
     * the &lt;tt&gt;indexes&lt;/tt&gt; and &lt;tt&gt;sizes&lt;/tt&gt;: two entries (index=a,size=b) and
     * (index=a,size=b') are equivalent to a single entry (index=a,size=b+b').
     *
     * @param indexes
     *            current positions of the instructions to be resized. Each
     *            instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *            byte, plus one (or, in other words, by the index of the
     *            &lt;i&gt;first&lt;/i&gt; byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes
     *            the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *            instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *            instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |
     *            &lt;tt&gt;sizes[i]&lt;/tt&gt;| bytes of the instruction will be removed
     *            (the instruction size &lt;i&gt;must not&lt;/i&gt; become negative or
     *            null).
     * @param begin
     *            index of the first byte of the source instruction.
     * @param end
     *            index of the first byte of the target instruction.
     * @return the future value of the given bytecode offset.
     */
    static int getNewOffset(final int[] indexes, final int[] sizes,
            final int begin, final int end) {
<span class="nc" id="L2874">        int offset = end - begin;</span>
<span class="nc bnc" id="L2875" title="All 2 branches missed.">        for (int i = 0; i &lt; indexes.length; ++i) {</span>
<span class="nc bnc" id="L2876" title="All 4 branches missed.">            if (begin &lt; indexes[i] &amp;&amp; indexes[i] &lt;= end) {</span>
                // forward jump
<span class="nc" id="L2878">                offset += sizes[i];</span>
<span class="nc bnc" id="L2879" title="All 4 branches missed.">            } else if (end &lt; indexes[i] &amp;&amp; indexes[i] &lt;= begin) {</span>
                // backward jump
<span class="nc" id="L2881">                offset -= sizes[i];</span>
            }
        }
<span class="nc" id="L2884">        return offset;</span>
    }

    /**
     * Updates the offset of the given label.
     *
     * @param indexes
     *            current positions of the instructions to be resized. Each
     *            instruction must be designated by the index of its &lt;i&gt;last&lt;/i&gt;
     *            byte, plus one (or, in other words, by the index of the
     *            &lt;i&gt;first&lt;/i&gt; byte of the &lt;i&gt;next&lt;/i&gt; instruction).
     * @param sizes
     *            the number of bytes to be &lt;i&gt;added&lt;/i&gt; to the above
     *            instructions. More precisely, for each i &lt; &lt;tt&gt;len&lt;/tt&gt;,
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] bytes will be added at the end of the
     *            instruction designated by &lt;tt&gt;indexes&lt;/tt&gt;[i] or, if
     *            &lt;tt&gt;sizes&lt;/tt&gt;[i] is negative, the &lt;i&gt;last&lt;/i&gt; |
     *            &lt;tt&gt;sizes[i]&lt;/tt&gt;| bytes of the instruction will be removed
     *            (the instruction size &lt;i&gt;must not&lt;/i&gt; become negative or
     *            null).
     * @param label
     *            the label whose offset must be updated.
     */
    static void getNewOffset(final int[] indexes, final int[] sizes,
            final Label label) {
<span class="nc bnc" id="L2909" title="All 2 branches missed.">        if ((label.status &amp; Label.RESIZED) == 0) {</span>
<span class="nc" id="L2910">            label.position = getNewOffset(indexes, sizes, 0, label.position);</span>
<span class="nc" id="L2911">            label.status |= Label.RESIZED;</span>
        }
<span class="nc" id="L2913">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>