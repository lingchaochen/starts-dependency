<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodVisitor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">starts-core</a> &gt; <a href="index.source.html" class="el_package">edu.illinois.starts.asm</a> &gt; <span class="el_source">MethodVisitor.java</span></div><h1>MethodVisitor.java</h1><pre class="source lang-java linenums">/***
 * ASM: a very small and fast Java bytecode manipulation framework
 * Copyright (c) 2000-2011 INRIA, France Telecom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holders nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
package edu.illinois.starts.asm;


/**
 * A visitor to visit a Java method. The methods of this class must be called in
 * the following order: ( &lt;tt&gt;visitParameter&lt;/tt&gt; )* [
 * &lt;tt&gt;visitAnnotationDefault&lt;/tt&gt; ] ( &lt;tt&gt;visitAnnotation&lt;/tt&gt; |
 * &lt;tt&gt;visitTypeAnnotation&lt;/tt&gt; | &lt;tt&gt;visitAttribute&lt;/tt&gt; )* [
 * &lt;tt&gt;visitCode&lt;/tt&gt; ( &lt;tt&gt;visitFrame&lt;/tt&gt; | &lt;tt&gt;visit&lt;i&gt;X&lt;/i&gt;Insn&lt;/tt&gt; |
 * &lt;tt&gt;visitLabel&lt;/tt&gt; | &lt;tt&gt;visitInsnAnnotation&lt;/tt&gt; |
 * &lt;tt&gt;visitTryCatchBlock&lt;/tt&gt; | &lt;tt&gt;visitTryCatchBlockAnnotation&lt;/tt&gt; |
 * &lt;tt&gt;visitLocalVariable&lt;/tt&gt; | &lt;tt&gt;visitLocalVariableAnnotation&lt;/tt&gt; |
 * &lt;tt&gt;visitLineNumber&lt;/tt&gt; )* &lt;tt&gt;visitMaxs&lt;/tt&gt; ] &lt;tt&gt;visitEnd&lt;/tt&gt;. In
 * addition, the &lt;tt&gt;visit&lt;i&gt;X&lt;/i&gt;Insn&lt;/tt&gt; and &lt;tt&gt;visitLabel&lt;/tt&gt; methods must
 * be called in the sequential order of the bytecode instructions of the visited
 * code, &lt;tt&gt;visitInsnAnnotation&lt;/tt&gt; must be called &lt;i&gt;after&lt;/i&gt; the annotated
 * instruction, &lt;tt&gt;visitTryCatchBlock&lt;/tt&gt; must be called &lt;i&gt;before&lt;/i&gt; the
 * labels passed as arguments have been visited,
 * &lt;tt&gt;visitTryCatchBlockAnnotation&lt;/tt&gt; must be called &lt;i&gt;after&lt;/i&gt; the
 * corresponding try catch block has been visited, and the
 * &lt;tt&gt;visitLocalVariable&lt;/tt&gt;, &lt;tt&gt;visitLocalVariableAnnotation&lt;/tt&gt; and
 * &lt;tt&gt;visitLineNumber&lt;/tt&gt; methods must be called &lt;i&gt;after&lt;/i&gt; the labels
 * passed as arguments have been visited.
 *
 * @author Eric Bruneton
 */
public abstract class MethodVisitor {

    /**
     * The ASM API version implemented by this visitor. The value of this field
     * must be one of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     */
    protected final int api;

    /**
     * The method visitor to which this visitor must delegate method calls. May
     * be null.
     */
    protected MethodVisitor mv;

    /**
     * Constructs a new {@link MethodVisitor}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     */
    public MethodVisitor(final int api) {
<span class="nc" id="L78">        this(api, null);</span>
<span class="nc" id="L79">    }</span>

    /**
     * Constructs a new {@link MethodVisitor}.
     *
     * @param api
     *            the ASM API version implemented by this visitor. Must be one
     *            of {@link Opcodes#ASM4} or {@link Opcodes#ASM5}.
     * @param mv
     *            the method visitor to which this visitor must delegate method
     *            calls. May be null.
     */
<span class="nc" id="L91">    public MethodVisitor(final int api, final MethodVisitor mv) {</span>
<span class="nc bnc" id="L92" title="All 4 branches missed.">        if (api != Opcodes.ASM4 &amp;&amp; api != Opcodes.ASM5) {</span>
<span class="nc" id="L93">            throw new IllegalArgumentException();</span>
        }
<span class="nc" id="L95">        this.api = api;</span>
<span class="nc" id="L96">        this.mv = mv;</span>
<span class="nc" id="L97">    }</span>

    // -------------------------------------------------------------------------
    // Parameters, annotations and non standard attributes
    // -------------------------------------------------------------------------

    /**
     * Visits a parameter of this method.
     *
     * @param name
     *            parameter name or null if none is provided.
     * @param access
     *            the parameter's access flags, only &lt;tt&gt;ACC_FINAL&lt;/tt&gt;,
     *            &lt;tt&gt;ACC_SYNTHETIC&lt;/tt&gt; or/and &lt;tt&gt;ACC_MANDATED&lt;/tt&gt; are
     *            allowed (see {@link Opcodes}).
     */
    public void visitParameter(String name, int access) {
<span class="nc bnc" id="L114" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L115">            throw new RuntimeException();</span>
        }
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L118">            mv.visitParameter(name, access);</span>
        }
<span class="nc" id="L120">    }</span>

    /**
     * Visits the default value of this annotation interface method.
     *
     * @return a visitor to the visit the actual default value of this
     *         annotation interface method, or &lt;tt&gt;null&lt;/tt&gt; if this visitor is
     *         not interested in visiting this default value. The 'name'
     *         parameters passed to the methods of this annotation visitor are
     *         ignored. Moreover, exacly one visit method must be called on this
     *         annotation visitor, followed by visitEnd.
     */
    public AnnotationVisitor visitAnnotationDefault() {
<span class="nc bnc" id="L133" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L134">            return mv.visitAnnotationDefault();</span>
        }
<span class="nc" id="L136">        return null;</span>
    }

    /**
     * Visits an annotation of this method.
     *
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
<span class="nc bnc" id="L150" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L151">            return mv.visitAnnotation(desc, visible);</span>
        }
<span class="nc" id="L153">        return null;</span>
    }

    /**
     * Visits an annotation on a type in the method signature.
     *
     * @param typeRef
     *            a reference to the annotated type. The sort of this type
     *            reference must be {@link TypeReference#METHOD_TYPE_PARAMETER
     *            METHOD_TYPE_PARAMETER},
     *            {@link TypeReference#METHOD_TYPE_PARAMETER_BOUND
     *            METHOD_TYPE_PARAMETER_BOUND},
     *            {@link TypeReference#METHOD_RETURN METHOD_RETURN},
     *            {@link TypeReference#METHOD_RECEIVER METHOD_RECEIVER},
     *            {@link TypeReference#METHOD_FORMAL_PARAMETER
     *            METHOD_FORMAL_PARAMETER} or {@link TypeReference#THROWS
     *            THROWS}. See {@link TypeReference}.
     * @param typePath
     *            the path to the annotated type argument, wildcard bound, array
     *            element type, or static inner type within 'typeRef'. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the annotation targets 'typeRef' as a whole.
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitTypeAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
<span class="nc bnc" id="L183" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L184">            throw new RuntimeException();</span>
        }
<span class="nc bnc" id="L186" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L187">            return mv.visitTypeAnnotation(typeRef, typePath, desc, visible);</span>
        }
<span class="nc" id="L189">        return null;</span>
    }

    /**
     * Visits an annotation of a parameter this method.
     *
     * @param parameter
     *            the parameter index.
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitParameterAnnotation(int parameter,
                                                      String desc, boolean visible) {
<span class="nc bnc" id="L206" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L207">            return mv.visitParameterAnnotation(parameter, desc, visible);</span>
        }
<span class="nc" id="L209">        return null;</span>
    }

    /**
     * Visits a non standard attribute of this method.
     *
     * @param attr
     *            an attribute.
     */
    public void visitAttribute(Attribute attr) {
<span class="nc bnc" id="L219" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L220">            mv.visitAttribute(attr);</span>
        }
<span class="nc" id="L222">    }</span>

    /**
     * Starts the visit of the method's code, if any (i.e. non abstract method).
     */
    public void visitCode() {
<span class="nc bnc" id="L228" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L229">            mv.visitCode();</span>
        }
<span class="nc" id="L231">    }</span>

    /**
     * Visits the current state of the local variables and operand stack
     * elements. This method must(*) be called &lt;i&gt;just before&lt;/i&gt; any
     * instruction &lt;b&gt;i&lt;/b&gt; that follows an unconditional branch instruction
     * such as GOTO or THROW, that is the target of a jump instruction, or that
     * starts an exception handler block. The visited types must describe the
     * values of the local variables and of the operand stack elements &lt;i&gt;just
     * before&lt;/i&gt; &lt;b&gt;i&lt;/b&gt; is executed.&lt;br&gt;
     * &lt;br&gt;
     * (*) this is mandatory only for classes whose version is greater than or
     * equal to {@link Opcodes#V1_6 V1_6}. &lt;br&gt;
     * &lt;br&gt;
     * The frames of a method must be given either in expanded form, or in
     * compressed form (all frames must use the same format, i.e. you must not
     * mix expanded and compressed frames within a single method):
     * &lt;ul&gt;
     * &lt;li&gt;In expanded form, all frames must have the F_NEW type.&lt;/li&gt;
     * &lt;li&gt;In compressed form, frames are basically &quot;deltas&quot; from the state of
     * the previous frame:
     * &lt;ul&gt;
     * &lt;li&gt;{@link Opcodes#F_SAME} representing frame with exactly the same
     * locals as the previous frame and with the empty stack.&lt;/li&gt;
     * &lt;li&gt;{@link Opcodes#F_SAME1} representing frame with exactly the same
     * locals as the previous frame and with single value on the stack (
     * &lt;code&gt;nStack&lt;/code&gt; is 1 and &lt;code&gt;stack[0]&lt;/code&gt; contains value for the
     * type of the stack item).&lt;/li&gt;
     * &lt;li&gt;{@link Opcodes#F_APPEND} representing frame with current locals are
     * the same as the locals in the previous frame, except that additional
     * locals are defined (&lt;code&gt;nLocal&lt;/code&gt; is 1, 2 or 3 and
     * &lt;code&gt;local&lt;/code&gt; elements contains values representing added types).&lt;/li&gt;
     * &lt;li&gt;{@link Opcodes#F_CHOP} representing frame with current locals are the
     * same as the locals in the previous frame, except that the last 1-3 locals
     * are absent and with the empty stack (&lt;code&gt;nLocals&lt;/code&gt; is 1, 2 or 3).&lt;/li&gt;
     * &lt;li&gt;{@link Opcodes#F_FULL} representing complete frame data.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;br&gt;
     * In both cases the first frame, corresponding to the method's parameters
     * and access flags, is implicit and must not be visited. Also, it is
     * illegal to visit two or more frames for the same code location (i.e., at
     * least one instruction must be visited between two calls to visitFrame).
     *
     * @param type
     *            the type of this stack map frame. Must be
     *            {@link Opcodes#F_NEW} for expanded frames, or
     *            {@link Opcodes#F_FULL}, {@link Opcodes#F_APPEND},
     *            {@link Opcodes#F_CHOP}, {@link Opcodes#F_SAME} or
     *            {@link Opcodes#F_APPEND}, {@link Opcodes#F_SAME1} for
     *            compressed frames.
     * @param nLocal
     *            the number of local variables in the visited frame.
     * @param local
     *            the local variable types in this frame. This array must not be
     *            modified. Primitive types are represented by
     *            {@link Opcodes#TOP}, {@link Opcodes#INTEGER},
     *            {@link Opcodes#FLOAT}, {@link Opcodes#LONG},
     *            {@link Opcodes#DOUBLE},{@link Opcodes#NULL} or
     *            {@link Opcodes#UNINITIALIZED_THIS} (long and double are
     *            represented by a single element). Reference types are
     *            represented by String objects (representing internal names),
     *            and uninitialized types by Label objects (this label
     *            designates the NEW instruction that created this uninitialized
     *            value).
     * @param nStack
     *            the number of operand stack elements in the visited frame.
     * @param stack
     *            the operand stack types in this frame. This array must not be
     *            modified. Its content has the same format as the &quot;local&quot;
     *            array.
     * @throws IllegalStateException
     *             if a frame is visited just after another one, without any
     *             instruction between the two (unless this frame is a
     *             Opcodes#F_SAME frame, in which case it is silently ignored).
     */
    public void visitFrame(int type, int nLocal, Object[] local, int nStack,
            Object[] stack) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L311">            mv.visitFrame(type, nLocal, local, nStack, stack);</span>
        }
<span class="nc" id="L313">    }</span>

    // -------------------------------------------------------------------------
    // Normal instructions
    // -------------------------------------------------------------------------

    /**
     * Visits a zero operand instruction.
     *
     * @param opcode
     *            the opcode of the instruction to be visited. This opcode is
     *            either NOP, ACONST_NULL, ICONST_M1, ICONST_0, ICONST_1,
     *            ICONST_2, ICONST_3, ICONST_4, ICONST_5, LCONST_0, LCONST_1,
     *            FCONST_0, FCONST_1, FCONST_2, DCONST_0, DCONST_1, IALOAD,
     *            LALOAD, FALOAD, DALOAD, AALOAD, BALOAD, CALOAD, SALOAD,
     *            IASTORE, LASTORE, FASTORE, DASTORE, AASTORE, BASTORE, CASTORE,
     *            SASTORE, POP, POP2, DUP, DUP_X1, DUP_X2, DUP2, DUP2_X1,
     *            DUP2_X2, SWAP, IADD, LADD, FADD, DADD, ISUB, LSUB, FSUB, DSUB,
     *            IMUL, LMUL, FMUL, DMUL, IDIV, LDIV, FDIV, DDIV, IREM, LREM,
     *            FREM, DREM, INEG, LNEG, FNEG, DNEG, ISHL, LSHL, ISHR, LSHR,
     *            IUSHR, LUSHR, IAND, LAND, IOR, LOR, IXOR, LXOR, I2L, I2F, I2D,
     *            L2I, L2F, L2D, F2I, F2L, F2D, D2I, D2L, D2F, I2B, I2C, I2S,
     *            LCMP, FCMPL, FCMPG, DCMPL, DCMPG, IRETURN, LRETURN, FRETURN,
     *            DRETURN, ARETURN, RETURN, ARRAYLENGTH, ATHROW, MONITORENTER,
     *            or MONITOREXIT.
     */
    public void visitInsn(int opcode) {
<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L341">            mv.visitInsn(opcode);</span>
        }
<span class="nc" id="L343">    }</span>

    /**
     * Visits an instruction with a single int operand.
     *
     * @param opcode
     *            the opcode of the instruction to be visited. This opcode is
     *            either BIPUSH, SIPUSH or NEWARRAY.
     * @param operand
     *            the operand of the instruction to be visited.&lt;br&gt;
     *            When opcode is BIPUSH, operand value should be between
     *            Byte.MIN_VALUE and Byte.MAX_VALUE.&lt;br&gt;
     *            When opcode is SIPUSH, operand value should be between
     *            Short.MIN_VALUE and Short.MAX_VALUE.&lt;br&gt;
     *            When opcode is NEWARRAY, operand value should be one of
     *            {@link Opcodes#T_BOOLEAN}, {@link Opcodes#T_CHAR},
     *            {@link Opcodes#T_FLOAT}, {@link Opcodes#T_DOUBLE},
     *            {@link Opcodes#T_BYTE}, {@link Opcodes#T_SHORT},
     *            {@link Opcodes#T_INT} or {@link Opcodes#T_LONG}.
     */
    public void visitIntInsn(int opcode, int operand) {
<span class="nc bnc" id="L364" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L365">            mv.visitIntInsn(opcode, operand);</span>
        }
<span class="nc" id="L367">    }</span>

    /**
     * Visits a local variable instruction. A local variable instruction is an
     * instruction that loads or stores the value of a local variable.
     *
     * @param opcode
     *            the opcode of the local variable instruction to be visited.
     *            This opcode is either ILOAD, LLOAD, FLOAD, DLOAD, ALOAD,
     *            ISTORE, LSTORE, FSTORE, DSTORE, ASTORE or RET.
     * @param var
     *            the operand of the instruction to be visited. This operand is
     *            the index of a local variable.
     */
    public void visitVarInsn(int opcode, int var) {
<span class="nc bnc" id="L382" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L383">            mv.visitVarInsn(opcode, var);</span>
        }
<span class="nc" id="L385">    }</span>

    /**
     * Visits a type instruction. A type instruction is an instruction that
     * takes the internal name of a class as parameter.
     *
     * @param opcode
     *            the opcode of the type instruction to be visited. This opcode
     *            is either NEW, ANEWARRAY, CHECKCAST or INSTANCEOF.
     * @param type
     *            the operand of the instruction to be visited. This operand
     *            must be the internal name of an object or array class (see
     *            {@link Type#getInternalName() getInternalName}).
     */
    public void visitTypeInsn(int opcode, String type) {
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L401">            mv.visitTypeInsn(opcode, type);</span>
        }
<span class="nc" id="L403">    }</span>

    /**
     * Visits a field instruction. A field instruction is an instruction that
     * loads or stores the value of a field of an object.
     *
     * @param opcode
     *            the opcode of the type instruction to be visited. This opcode
     *            is either GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.
     * @param owner
     *            the internal name of the field's owner class (see
     *            {@link Type#getInternalName() getInternalName}).
     * @param name
     *            the field's name.
     * @param desc
     *            the field's descriptor (see {@link Type Type}).
     */
    public void visitFieldInsn(int opcode, String owner, String name,
            String desc) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L423">            mv.visitFieldInsn(opcode, owner, name, desc);</span>
        }
<span class="nc" id="L425">    }</span>

    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     *            the opcode of the type instruction to be visited. This opcode
     *            is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     *            INVOKEINTERFACE.
     * @param owner
     *            the internal name of the method's owner class (see
     *            {@link Type#getInternalName() getInternalName}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     */
    @Deprecated
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc) {
<span class="nc bnc" id="L446" title="All 2 branches missed.">        if (api &gt;= Opcodes.ASM5) {</span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">            boolean itf = opcode == Opcodes.INVOKEINTERFACE;</span>
<span class="nc" id="L448">            visitMethodInsn(opcode, owner, name, desc, itf);</span>
<span class="nc" id="L449">            return;</span>
        }
<span class="nc bnc" id="L451" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L452">            mv.visitMethodInsn(opcode, owner, name, desc);</span>
        }
<span class="nc" id="L454">    }</span>

    /**
     * Visits a method instruction. A method instruction is an instruction that
     * invokes a method.
     *
     * @param opcode
     *            the opcode of the type instruction to be visited. This opcode
     *            is either INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or
     *            INVOKEINTERFACE.
     * @param owner
     *            the internal name of the method's owner class (see
     *            {@link Type#getInternalName() getInternalName}).
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     * @param itf
     *            if the method's owner class is an interface.
     */
    public void visitMethodInsn(int opcode, String owner, String name,
            String desc, boolean itf) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc bnc" id="L477" title="All 4 branches missed.">            if (itf != (opcode == Opcodes.INVOKEINTERFACE)) {</span>
<span class="nc" id="L478">                throw new IllegalArgumentException(</span>
                        &quot;INVOKESPECIAL/STATIC on interfaces require ASM 5&quot;);
            }
<span class="nc" id="L481">            visitMethodInsn(opcode, owner, name, desc);</span>
<span class="nc" id="L482">            return;</span>
        }
<span class="nc bnc" id="L484" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L485">            mv.visitMethodInsn(opcode, owner, name, desc, itf);</span>
        }
<span class="nc" id="L487">    }</span>

    /**
     * Visits an invokedynamic instruction.
     *
     * @param name
     *            the method's name.
     * @param desc
     *            the method's descriptor (see {@link Type Type}).
     * @param bsm
     *            the bootstrap method.
     * @param bsmArgs
     *            the bootstrap method constant arguments. Each argument must be
     *            an {@link Integer}, {@link Float}, {@link Long},
     *            {@link Double}, {@link String}, {@link Type} or {@link Handle}
     *            value. This method is allowed to modify the content of the
     *            array so a caller should expect that this array may change.
     */
    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
            Object... bsmArgs) {
<span class="nc bnc" id="L507" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L508">            mv.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);</span>
        }
<span class="nc" id="L510">    }</span>

    /**
     * Visits a jump instruction. A jump instruction is an instruction that may
     * jump to another instruction.
     *
     * @param opcode
     *            the opcode of the type instruction to be visited. This opcode
     *            is either IFEQ, IFNE, IFLT, IFGE, IFGT, IFLE, IF_ICMPEQ,
     *            IF_ICMPNE, IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,
     *            IF_ACMPEQ, IF_ACMPNE, GOTO, JSR, IFNULL or IFNONNULL.
     * @param label
     *            the operand of the instruction to be visited. This operand is
     *            a label that designates the instruction to which the jump
     *            instruction may jump.
     */
    public void visitJumpInsn(int opcode, Label label) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L528">            mv.visitJumpInsn(opcode, label);</span>
        }
<span class="nc" id="L530">    }</span>

    /**
     * Visits a label. A label designates the instruction that will be visited
     * just after it.
     *
     * @param label
     *            a {@link Label Label} object.
     */
    public void visitLabel(Label label) {
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L541">            mv.visitLabel(label);</span>
        }
<span class="nc" id="L543">    }</span>

    // -------------------------------------------------------------------------
    // Special instructions
    // -------------------------------------------------------------------------

    /**
     * Visits a LDC instruction. Note that new constant types may be added in
     * future versions of the Java Virtual Machine. To easily detect new
     * constant types, implementations of this method should check for
     * unexpected constant types, like this:
     *
     * &lt;pre&gt;
     * if (cst instanceof Integer) {
     *     // ...
     * } else if (cst instanceof Float) {
     *     // ...
     * } else if (cst instanceof Long) {
     *     // ...
     * } else if (cst instanceof Double) {
     *     // ...
     * } else if (cst instanceof String) {
     *     // ...
     * } else if (cst instanceof Type) {
     *     int sort = ((Type) cst).getSort();
     *     if (sort == Type.OBJECT) {
     *         // ...
     *     } else if (sort == Type.ARRAY) {
     *         // ...
     *     } else if (sort == Type.METHOD) {
     *         // ...
     *     } else {
     *         // throw an exception
     *     }
     * } else if (cst instanceof Handle) {
     *     // ...
     * } else {
     *     // throw an exception
     * }
     * &lt;/pre&gt;
     *
     * @param cst
     *            the constant to be loaded on the stack. This parameter must be
     *            a non null {@link Integer}, a {@link Float}, a {@link Long}, a
     *            {@link Double}, a {@link String}, a {@link Type} of OBJECT or
     *            ARRAY sort for &lt;tt&gt;.class&lt;/tt&gt; constants, for classes whose
     *            version is 49.0, a {@link Type} of METHOD sort or a
     *            {@link Handle} for MethodType and MethodHandle constants, for
     *            classes whose version is 51.0.
     */
    public void visitLdcInsn(Object cst) {
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L595">            mv.visitLdcInsn(cst);</span>
        }
<span class="nc" id="L597">    }</span>

    /**
     * Visits an IINC instruction.
     *
     * @param var
     *            index of the local variable to be incremented.
     * @param increment
     *            amount to increment the local variable by.
     */
    public void visitIincInsn(int var, int increment) {
<span class="nc bnc" id="L608" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L609">            mv.visitIincInsn(var, increment);</span>
        }
<span class="nc" id="L611">    }</span>

    /**
     * Visits a TABLESWITCH instruction.
     *
     * @param min
     *            the minimum key value.
     * @param max
     *            the maximum key value.
     * @param dflt
     *            beginning of the default handler block.
     * @param labels
     *            beginnings of the handler blocks. &lt;tt&gt;labels[i]&lt;/tt&gt; is the
     *            beginning of the handler block for the &lt;tt&gt;min + i&lt;/tt&gt; key.
     */
    public void visitTableSwitchInsn(int min, int max, Label dflt,
            Label... labels) {
<span class="nc bnc" id="L628" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L629">            mv.visitTableSwitchInsn(min, max, dflt, labels);</span>
        }
<span class="nc" id="L631">    }</span>

    /**
     * Visits a LOOKUPSWITCH instruction.
     *
     * @param dflt
     *            beginning of the default handler block.
     * @param keys
     *            the values of the keys.
     * @param labels
     *            beginnings of the handler blocks. &lt;tt&gt;labels[i]&lt;/tt&gt; is the
     *            beginning of the handler block for the &lt;tt&gt;keys[i]&lt;/tt&gt; key.
     */
    public void visitLookupSwitchInsn(Label dflt, int[] keys, Label[] labels) {
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L646">            mv.visitLookupSwitchInsn(dflt, keys, labels);</span>
        }
<span class="nc" id="L648">    }</span>

    /**
     * Visits a MULTIANEWARRAY instruction.
     *
     * @param desc
     *            an array type descriptor (see {@link Type Type}).
     * @param dims
     *            number of dimensions of the array to allocate.
     */
    public void visitMultiANewArrayInsn(String desc, int dims) {
<span class="nc bnc" id="L659" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L660">            mv.visitMultiANewArrayInsn(desc, dims);</span>
        }
<span class="nc" id="L662">    }</span>

    /**
     * Visits an annotation on an instruction. This method must be called just
     * &lt;i&gt;after&lt;/i&gt; the annotated instruction. It can be called several times
     * for the same instruction.
     *
     * @param typeRef
     *            a reference to the annotated type. The sort of this type
     *            reference must be {@link TypeReference#INSTANCEOF INSTANCEOF},
     *            {@link TypeReference#NEW NEW},
     *            {@link TypeReference#CONSTRUCTOR_REFERENCE
     *            CONSTRUCTOR_REFERENCE}, {@link TypeReference#METHOD_REFERENCE
     *            METHOD_REFERENCE}, {@link TypeReference#CAST CAST},
     *            {@link TypeReference#CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT
     *            CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT},
     *            {@link TypeReference#METHOD_INVOCATION_TYPE_ARGUMENT
     *            METHOD_INVOCATION_TYPE_ARGUMENT},
     *            {@link TypeReference#CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT
     *            CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT}, or
     *            {@link TypeReference#METHOD_REFERENCE_TYPE_ARGUMENT
     *            METHOD_REFERENCE_TYPE_ARGUMENT}. See {@link TypeReference}.
     * @param typePath
     *            the path to the annotated type argument, wildcard bound, array
     *            element type, or static inner type within 'typeRef'. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the annotation targets 'typeRef' as a whole.
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitInsnAnnotation(int typeRef,
                                                 TypePath typePath, String desc, boolean visible) {
<span class="nc bnc" id="L697" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L698">            throw new RuntimeException();</span>
        }
<span class="nc bnc" id="L700" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L701">            return mv.visitInsnAnnotation(typeRef, typePath, desc, visible);</span>
        }
<span class="nc" id="L703">        return null;</span>
    }

    // -------------------------------------------------------------------------
    // Exceptions table entries, debug information, max stack and max locals
    // -------------------------------------------------------------------------

    /**
     * Visits a try catch block.
     *
     * @param start
     *            beginning of the exception handler's scope (inclusive).
     * @param end
     *            end of the exception handler's scope (exclusive).
     * @param handler
     *            beginning of the exception handler's code.
     * @param type
     *            internal name of the type of exceptions handled by the
     *            handler, or &lt;tt&gt;null&lt;/tt&gt; to catch any exceptions (for
     *            &quot;finally&quot; blocks).
     * @throws IllegalArgumentException
     *             if one of the labels has already been visited by this visitor
     *             (by the {@link #visitLabel visitLabel} method).
     */
    public void visitTryCatchBlock(Label start, Label end, Label handler,
                                   String type) {
<span class="nc bnc" id="L729" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L730">            mv.visitTryCatchBlock(start, end, handler, type);</span>
        }
<span class="nc" id="L732">    }</span>

    /**
     * Visits an annotation on an exception handler type. This method must be
     * called &lt;i&gt;after&lt;/i&gt; the {@link #visitTryCatchBlock} for the annotated
     * exception handler. It can be called several times for the same exception
     * handler.
     *
     * @param typeRef
     *            a reference to the annotated type. The sort of this type
     *            reference must be {@link TypeReference#EXCEPTION_PARAMETER
     *            EXCEPTION_PARAMETER}. See {@link TypeReference}.
     * @param typePath
     *            the path to the annotated type argument, wildcard bound, array
     *            element type, or static inner type within 'typeRef'. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the annotation targets 'typeRef' as a whole.
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitTryCatchAnnotation(int typeRef,
                                                     TypePath typePath, String desc, boolean visible) {
<span class="nc bnc" id="L757" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L758">            throw new RuntimeException();</span>
        }
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L761">            return mv.visitTryCatchAnnotation(typeRef, typePath, desc, visible);</span>
        }
<span class="nc" id="L763">        return null;</span>
    }

    /**
     * Visits a local variable declaration.
     *
     * @param name
     *            the name of a local variable.
     * @param desc
     *            the type descriptor of this local variable.
     * @param signature
     *            the type signature of this local variable. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the local variable type does not use generic
     *            types.
     * @param start
     *            the first instruction corresponding to the scope of this local
     *            variable (inclusive).
     * @param end
     *            the last instruction corresponding to the scope of this local
     *            variable (exclusive).
     * @param index
     *            the local variable's index.
     * @throws IllegalArgumentException
     *             if one of the labels has not already been visited by this
     *             visitor (by the {@link #visitLabel visitLabel} method).
     */
    public void visitLocalVariable(String name, String desc, String signature,
                                   Label start, Label end, int index) {
<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L792">            mv.visitLocalVariable(name, desc, signature, start, end, index);</span>
        }
<span class="nc" id="L794">    }</span>

    /**
     * Visits an annotation on a local variable type.
     *
     * @param typeRef
     *            a reference to the annotated type. The sort of this type
     *            reference must be {@link TypeReference#LOCAL_VARIABLE
     *            LOCAL_VARIABLE} or {@link TypeReference#RESOURCE_VARIABLE
     *            RESOURCE_VARIABLE}. See {@link TypeReference}.
     * @param typePath
     *            the path to the annotated type argument, wildcard bound, array
     *            element type, or static inner type within 'typeRef'. May be
     *            &lt;tt&gt;null&lt;/tt&gt; if the annotation targets 'typeRef' as a whole.
     * @param start
     *            the fist instructions corresponding to the continuous ranges
     *            that make the scope of this local variable (inclusive).
     * @param end
     *            the last instructions corresponding to the continuous ranges
     *            that make the scope of this local variable (exclusive). This
     *            array must have the same size as the 'start' array.
     * @param index
     *            the local variable's index in each range. This array must have
     *            the same size as the 'start' array.
     * @param desc
     *            the class descriptor of the annotation class.
     * @param visible
     *            &lt;tt&gt;true&lt;/tt&gt; if the annotation is visible at runtime.
     * @return a visitor to visit the annotation values, or &lt;tt&gt;null&lt;/tt&gt; if
     *         this visitor is not interested in visiting this annotation.
     */
    public AnnotationVisitor visitLocalVariableAnnotation(int typeRef,
                                                          TypePath typePath, Label[] start, Label[] end, int[] index,
                                                          String desc, boolean visible) {
<span class="nc bnc" id="L828" title="All 2 branches missed.">        if (api &lt; Opcodes.ASM5) {</span>
<span class="nc" id="L829">            throw new RuntimeException();</span>
        }
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L832">            return mv.visitLocalVariableAnnotation(typeRef, typePath, start,</span>
                    end, index, desc, visible);
        }
<span class="nc" id="L835">        return null;</span>
    }

    /**
     * Visits a line number declaration.
     *
     * @param line
     *            a line number. This number refers to the source file from
     *            which the class was compiled.
     * @param start
     *            the first instruction corresponding to this line number.
     * @throws IllegalArgumentException
     *             if &lt;tt&gt;start&lt;/tt&gt; has not already been visited by this
     *             visitor (by the {@link #visitLabel visitLabel} method).
     */
    public void visitLineNumber(int line, Label start) {
<span class="nc bnc" id="L851" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L852">            mv.visitLineNumber(line, start);</span>
        }
<span class="nc" id="L854">    }</span>

    /**
     * Visits the maximum stack size and the maximum number of local variables
     * of the method.
     *
     * @param maxStack
     *            maximum stack size of the method.
     * @param maxLocals
     *            maximum number of local variables for the method.
     */
    public void visitMaxs(int maxStack, int maxLocals) {
<span class="nc bnc" id="L866" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L867">            mv.visitMaxs(maxStack, maxLocals);</span>
        }
<span class="nc" id="L869">    }</span>

    /**
     * Visits the end of the method. This method, which is the last one to be
     * called, is used to inform the visitor that all the annotations and
     * attributes of the method have been visited.
     */
    public void visitEnd() {
<span class="nc bnc" id="L877" title="All 2 branches missed.">        if (mv != null) {</span>
<span class="nc" id="L878">            mv.visitEnd();</span>
        }
<span class="nc" id="L880">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>